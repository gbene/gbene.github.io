[{"authors":null,"categories":null,"content":"About this site This site is ment to function as a place to organize and archive my projects in a single place. Too many times I\u0026rsquo;ve started a project and never finish it because I\u0026rsquo;ve forgot about it or it became too messy to start all over again. By creating this site I hope to build a solid structure as future reference, use it to document the progress over time and help me reconsider and/or finish suspended projects. The site is build in Go Hugo, an open source static site generator available under the Apache Licence 2.0.\nAbout me I\u0026rsquo;m a 23 years old geology student with a passion for science, technology, woodworking, nature and photography. I was always fascinated by the complexity of our Earth and during my academic course I found (and still find) endless possibilities of applying modern technology and coding to many geology concepts. It doesn\u0026rsquo;t help that I love puzzles, dissasembling different objects, fixing stuff and try to understand how different parts and different objects work and can relate. Because of this I love to get my hands dirty by always learing something new (tools, softwares, etc\u0026hellip;) and create specific tools to help me understand.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://gabri.xyz/author/gabriele-benedetti/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/gabriele-benedetti/","section":"authors","summary":"About this site This site is ment to function as a place to organize and archive my projects in a single place. Too many times I\u0026rsquo;ve started a project and never finish it because I\u0026rsquo;ve forgot about it or it became too messy to start all over again.","tags":null,"title":"Gabriele Benedetti","type":"authors"},{"authors":null,"categories":null,"content":"The main window of PZero is composed by three main interfaces:\nThe menu. The toolbar. The project explorer.  The menu and toolbar The menu at the top of the window (A) groups all of the available PZero functions and viewers. The main categories are:\n File: Input and output functions Edit: Object managment functions (properties, textures etcetc) Interpolation: Interpolation and object manipulation functions Window: Different viewers (3D, map view, section view etcetc)  The same subdivisions and functions are present in the toolbar (B).\nThe project explorer ","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"a0cccfc0c00fea156a1642deb3c78979","permalink":"https://gabri.xyz/documentations/pzero/interface/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/interface/","section":"documentations","summary":"The main window of PZero is composed by three main interfaces:\nThe menu. The toolbar. The project explorer.  The menu and toolbar The menu at the top of the window (A) groups all of the available PZero functions and viewers.","tags":null,"title":"Interface overview","type":"book"},{"authors":null,"categories":null,"content":"About PZero is a Python open-source 3D geological modelling application, leveraging various libraries, with a user-friendly graphical user interface allowing to perform most standard geomodelling data management and analysis tasks, explicit surface interpolation, and advanced implicit interpolation.\nTo build PZero we use several open-source libraries. VTK provides classes for all 3D objects, in addition to 3D visualization and basic analysis and modelling tools. The PZero graphical user interface is built with Qt. All objects in a PZero project and their metadata are collected and managed in pandas dataframes. We use a VTK-Numpy interface that allows performing most mathematical processing with simple NumPy syntax, while 2D plotting is performed with Matplotlib. PyVista and vedo provide simplified access to VTK visualization and I/O tools. Various 2D graphical and topological editing tools in PZero are based on Shapely, while GeoPandas, Rasterio, Xarray, and EzDxf provide I/O tools for GIS and CAD data. LoopStructural provides three different implicit surface interpolation algorithms.\nAll the developers of these libraries are warmly thanked!\nThe PZero project started in spring 2020 thanks to a research project funded by Pro Iter Tunnelling \u0026amp; Geotechnical Department and lead by Andrea Bistacchi and Luca Soldo.\nThe PZero developers are:\n Andrea Bistacchi (since the beginning) Gloria Arienti (since December 2020) Gabriele Benedetti (since January 2022)  PZero © 2020 by Andrea Bistacchi, released under GNU AGPLv3 license.\n  The name of PZero was inspired by the zeroth element in Emile Argand\u0026rsquo;s 3D model of the Pennine Alps nappe stack - possibly the first quantitative 3D geological model in the history of geological sciences (Argand E., 1911. Les Nappes de recouvrement des Alpes pennines et leurs prolongements structuraux. Mat. Carte géol. Suisse, 31, 1-26).\nWhere to download PZero can be downloaded from it\u0026rsquo;s official github repository: https://github.com/andrea-bistacchi/PZero\nHow to install PZero runs on Linux, macOS and Windows.\nWindows At the moment the easiest way to run and develop new code for PZero is to have a suitable Anaconda environment.\nIn the conda terminal, navigate to the PZero folder that you have cloned with Git or simply downloaded and import the environment with:\nconda env create -n pzero -f environment.yml conda activate pzero  Then you can start PZero with:\npython pzero_run.py  To activate and deactivate the pzero environment, and in case you want to remove it completely, use respectively (in conda terminal):\nconda activate pzero conda deactivate  MacOS It is also possible to install PZero on macOS without Anaconda. For this Homebrew is needed and, in order not to alter the base Python environment, we strongly suggest to create a dedicated virtual environment using virtualenvwrapper.\nAll the following commands must be entered in the macOS Terminal. First Homebrew, Python 3 (needed because the default Python on macOS is Python 2) and virtualenvwrapper are installed:\n/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot; brew install python3 brew install virtualenvwrapper  Then to be able to use virtualenvwrapper, some lines must be added to the options file of the zsh shell (the shell that runs in the macOS Terminal). The options file can be opened with:\nnano ~/.zshrc  Then the following lines must be pasted and the file saved with control+X.\n# lines needed by virtualenvwrapper export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/Devel source /usr/local/bin/virtualenvwrapper.sh  After restarting the Terminal, a virtual environment called pzero based on Python 3.8 can be created and activated:\nmkvirtualenv --python=3.8 pzero workon pzero  When the pzero environment is active, it will be highlighted within brackets at the command prompt, as in:\n(pzero) \u0026lt;user\u0026gt;@\u0026lt;machine\u0026gt; \u0026lt;directory\u0026gt; %  To activate and deactivate the pzero environment, and in case you want to remove it completely, use respectively:\nworkon pzero deactivate rmvirtualenv pzero  All the lines above, from brew install virtualenvwrapper, can be skipped in case a virtual environment is not being created, or created using a different virtual environment manager.\nNow the Python modules required by PZero can be automatically installed using pip3 (not pip that will point to Python 2) within the PZero directory downloaded from GitHub.\npip3 install -r requirements.txt  And finally PZero can be run with:\npython3 pzero_run.py  Linux Pip installaton For Debian based Linux distros pip can be installed using the apt package manager.\n Check if packages and dependencies need to be upgraded (routine check):  sudo apt update sudo apt upgrade  Install pip3:  sudo apt install python3-pip  Install requirements with pip To install the required python3 modules we can just run:\npip3 install -r /path/to/requirements.txt  After the required packages are installed PZero can be run with:\npython3 pzero_run.py  Conda installation (optional): Conda can also be installed on Linux by following this quick guide. After installing conda a pzero environment can be created and activated in the same way as in the other OSs. To install the required packages in a given environment follow the steps above after activating the environment.\n","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"00a41748d0af3d7a3565a1cf65a48f31","permalink":"https://gabri.xyz/documentations/pzero/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/","section":"documentations","summary":"An open source 3D geological modelling software.","tags":null,"title":"PZero","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"7ff35fc3a8257618aa749b6b26918cc7","permalink":"https://gabri.xyz/documentations/pzero/interpolation/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/interpolation/","section":"documentations","summary":"","tags":null,"title":"Interpolation","type":"book"},{"authors":null,"categories":null,"content":"About RocLab is a very useful piece of free software written in 2011 for determining rock mass strength parameters, based on the generalized Hoek-Brown failure criterion (Hoek et al. 2002). The main problem is that it is discontinued and the only version is available for windows. With the Rocpy project the same RocLab\u0026rsquo;s objective are archived using python increasing the overall accessibility of the program and improve the interface.\nCapabilities RocPy can:\n Calculate Hoek-Brown criterion parameters Calculate Rock mass parameters (σ_t, σ_c, σ_cm, E_rm) Calculate σ_3max based on different applications (e.g tunnels) Calculate Mohr-Coulomb parameters (c and φ) Plot H-B and M-C envelope. Failure mohr circle plot and σ_1max value.        Where to download RocPy can be downloaded directly from the main github repository: https://github.com/gbene/Rocpy\nInstallation RocPy can be run directly using Python. The only additional required dependency are Numpy and PyQt\npip install numpy  pip install pyqt5  ","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"0ae28791351a628e19b21ebd77516201","permalink":"https://gabri.xyz/documentations/rocpy/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/rocpy/","section":"documentations","summary":"Roclab inspired python program","tags":null,"title":"RocPy","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"951ced518e2ef3ce9f5a2574c9382033","permalink":"https://gabri.xyz/documentations/pzero/viewers/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/viewers/","section":"documentations","summary":"","tags":null,"title":"Viewers","type":"book"},{"authors":null,"categories":null,"content":"About Pydip is a python program with the main objective to give a stereoplot reading practice platform by generating random planes, folds, faults and focal mechanisms.\nCapabilities: The capabilities of PyDip are:\n Generate multiple random sets of planes Generate multiple random sets of folds Generate random focal mechanisms Data table view and selection Import and plot imported data  Where to download PyDip can be dowloaded directly from the main github repository:\nhttps://github.com/gbene/pydip/\nInstallation PyDip can be run directly using Python\npython3 pydip_gui.py  But it needs some additional packages such as OBSpy, numpy and PyQt5\npip install obspy  pip install numpy  pip install pyqt5  ","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"49d14fc6aaaeee031efd302c573dd2da","permalink":"https://gabri.xyz/documentations/pydip/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pydip/","section":"documentations","summary":"Random structural data generator such as planes, folds, faults and focal mechanisms.","tags":null,"title":"PyDip","type":"book"},{"authors":null,"categories":null,"content":"Table of contents of all available PZero functions.\n1. File Project managment  New project: Crate a new PZero project by choosing the files name and path. Open project: Open an already existing PZero project Save project: Save modified PZero project.  Import/Export PZero can read and import several different formats such as:\n Gocad objects (gocad ascii) PyVista Point cloud data (.txt;.csv;.xyz;.las and .laz; .ply) Vedo Shapefiles (.shp) Digital Earth Models (.geotiff) Orthoimage SEG-Y  PZero can export in several different formats such as:\n STL (normal and with 1m dilation) DXF GOCAD PLY OBJ  2. Edit 3. Interpolation 4. Window ","date":1648944000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1648944000,"objectID":"32f8d8b71ae4a9ba119d0c99aa808665","permalink":"https://gabri.xyz/documentations/pzero/functions/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/","section":"documentations","summary":"Table of contents of all available PZero functions.\n1. File Project managment  New project: Crate a new PZero project by choosing the files name and path. Open project: Open an already existing PZero project Save project: Save modified PZero project.","tags":null,"title":"Function list","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"b7a6ffb9868240639179acacf02b31f4","permalink":"https://gabri.xyz/documentations/pzero/viewers/3dview/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/viewers/3dview/","section":"documentations","summary":"","tags":null,"title":"3D viewer","type":"book"},{"authors":null,"categories":null,"content":"Generate random planes       Pydip is able to generate n sets of random planes composed by a set number of planes. The program chooses a random dip direction and angle for every set and depending on that plane the planes will be generated with a normal distribuition with a random std value.\nOptions The parameters that can be tweaked are:\n Number of sets Number of planes Plot planes and/or poles  ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"9f1bdad3372284320eb3096bcd3a274c","permalink":"https://gabri.xyz/documentations/pydip/planes/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pydip/planes/","section":"documentations","summary":"Generate random planes       Pydip is able to generate n sets of random planes composed by a set number of planes. The program chooses a random dip direction and angle for every set and depending on that plane the planes will be generated with a normal distribuition with a random std value.","tags":null,"title":"Generate random planes","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"86d778e939bfc00fa15904634c7a01fb","permalink":"https://gabri.xyz/documentations/pzero/viewers/mapview/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/viewers/mapview/","section":"documentations","summary":"","tags":null,"title":"Map viewer","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"fdd08f1ddfde9f29f4a95ee80b437484","permalink":"https://gabri.xyz/documentations/pzero/viewers/xsection/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/viewers/xsection/","section":"documentations","summary":"","tags":null,"title":"Cross section viewer","type":"book"},{"authors":null,"categories":null,"content":"   Pydip is able to generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nOptions The parameters that can be tweaked are:\n Number of sets of folds Number of planes for every fold limb Plot limb planes and/or poles Plot plane axis and/or hinge line  ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"f489be6db359d40b8cf537cf606c6511","permalink":"https://gabri.xyz/documentations/pydip/folds/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pydip/folds/","section":"documentations","summary":"Pydip is able to generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nOptions The parameters that can be tweaked are:","tags":null,"title":"Generate random folds","type":"book"},{"authors":null,"categories":null,"content":"   Pydip is able to generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nOptions The parameters that can be tweaked are:\n Number of sets of folds Number of planes for every fold limb Plot limb planes and/or poles Plot plane axis and/or hinge line  ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"6414735ca91633bb851f6040950864f9","permalink":"https://gabri.xyz/documentations/rocpy/folds/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/rocpy/folds/","section":"documentations","summary":"Pydip is able to generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nOptions The parameters that can be tweaked are:","tags":null,"title":"Generate random folds","type":"book"},{"authors":null,"categories":null,"content":"Pydip is able to generate 4 sets of random focal mechanisms plots (beach balls).\n   ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"75c4fde337ee5b43d792801b9e93957b","permalink":"https://gabri.xyz/documentations/pydip/focal/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pydip/focal/","section":"documentations","summary":"Pydip is able to generate 4 sets of random focal mechanisms plots (beach balls).\n   ","tags":null,"title":"Generate random focal mechanisms","type":"book"},{"authors":null,"categories":null,"content":"Pydip is able to generate 4 sets of random focal mechanisms plots (beach balls).\n   ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"34b319a89ba765b02d80e3ca4cb3bf0d","permalink":"https://gabri.xyz/documentations/rocpy/focal/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/rocpy/focal/","section":"documentations","summary":"Pydip is able to generate 4 sets of random focal mechanisms plots (beach balls).\n   ","tags":null,"title":"Generate random focal mechanisms","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"0dc52560cc8ff86c03cd39063e144e7b","permalink":"https://gabri.xyz/documentations/pzero/functions/gocad/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/gocad/","section":"documentations","summary":"","tags":null,"title":"Import Gocad","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"3771b86937c69cdcf7a77a0a026fdf87","permalink":"https://gabri.xyz/documentations/pzero/functions/gocadx/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/gocadx/","section":"documentations","summary":"","tags":null,"title":"Import Gocad Xsection","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"13c27e7b6913c495318bda9e1b947fc2","permalink":"https://gabri.xyz/documentations/pzero/functions/gocadb/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/gocadb/","section":"documentations","summary":"","tags":null,"title":"Import Gocad boudary","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"e297a337e34e7a4b9149e0158d90470a","permalink":"https://gabri.xyz/documentations/pzero/interpolation/explicit/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/interpolation/explicit/","section":"documentations","summary":"","tags":null,"title":"Explicit modelling","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"bfc200d754bdbad64d1d250f84e462ab","permalink":"https://gabri.xyz/documentations/pzero/interpolation/implicit/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/interpolation/implicit/","section":"documentations","summary":"","tags":null,"title":"Implicit modelling","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"3e148273dc3885d9d17d9ba0ea486aeb","permalink":"https://gabri.xyz/documentations/pzero/functions/pyvista/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/pyvista/","section":"documentations","summary":"","tags":null,"title":"Import PyVista","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"c4c3411b91ef4f2cae33351e0d5e3242","permalink":"https://gabri.xyz/documentations/pzero/functions/pc/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/pc/","section":"documentations","summary":"","tags":null,"title":"Import point cloud data","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"81a3c5cf725dccb9906f7a0851f86f4b","permalink":"https://gabri.xyz/documentations/pzero/functions/vedo/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/vedo/","section":"documentations","summary":"","tags":null,"title":"Import Vedo","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"836f637d2448e4f79e3f27d5fcf08bbc","permalink":"https://gabri.xyz/documentations/pzero/functions/dem/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/dem/","section":"documentations","summary":"","tags":null,"title":"Import DEM","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"464d473c7138747ba1c4398b9b251e72","permalink":"https://gabri.xyz/documentations/pzero/functions/ortho/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/ortho/","section":"documentations","summary":"","tags":null,"title":"Import OrthoImage","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"31c3d006a46f0e181d889ae12f6efbbd","permalink":"https://gabri.xyz/documentations/pzero/functions/shp/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/shp/","section":"documentations","summary":"","tags":null,"title":"Import SHP","type":"book"},{"authors":null,"categories":null,"content":"","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"1cd78c803967050ced1e82cba86b435c","permalink":"https://gabri.xyz/documentations/pzero/functions/segy/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pzero/functions/segy/","section":"documentations","summary":"","tags":null,"title":"Import SEGY","type":"book"},{"authors":null,"categories":null,"content":" Faults Better selection options Better import functions Statistics module 3D viewer for plotted structures  ","date":1648944000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1648944000,"objectID":"ba24ffac57ed9babb36aa3dd3788cf02","permalink":"https://gabri.xyz/documentations/pydip/plan/","publishdate":"2022-04-03T00:00:00Z","relpermalink":"/documentations/pydip/plan/","section":"documentations","summary":" Faults Better selection options Better import functions Statistics module 3D viewer for plotted structures  ","tags":null,"title":"List of planned features","type":"book"},{"authors":null,"categories":null,"content":"TS lists are a type of output files that are produced by WRF during a simulation to register the calculated values in specific coordinates. The raw output format of these files is not universal and it makes importing this kind of data a big hassle in other programs (such as excel). To contrast this problem I created this page that can be used to convert any TSLISTS in a properly formatted csv file and if necessary do some simple conversion and calculations (such as converting the time column from hours to days).\nThis converter uses javascript to import and manipulate the data. Everything is done locally so it works even offline if the page is saved.\n NOTE: For now batch conversion is not supported. You need to convert one file at a time.\n Todo  Batch conversions Mean caluclations over time User defined separator   Converter   File(s) size  html { font-family: sans-serif; } div#drop_box { height: 400px; width: 400px; border: 3px solid; display: flex; justify-content: center; flex-direction: column; align-items: center; border-radius: 4px; } input[type='file'] { color: transparent; } button, input[type='file']::file-selector-button { background-color: #4CAF50; /* Green */ border: none; color: white; padding: 10px 15px; text-align: center; text-decoration: none; display: inline-block; font-size: 20px; border-radius: 3px; } pre { display: -webkit-box; -webkit-line-clamp: 10; -webkit-box-orient: vertical; } .dropBox{ font-size: 1.15em; } .formCtrl{ font-size: 1.15em; font-weight: normal; line-height: 1.1; display: grid; grid-template-columns: 1em auto; gap: 0.5em; } input[type='radio']{ width: 1em; height: 1em; }   Input options or  Drop to upload  Drop here  Chosen file/s  Conversion options Time options Convert hours in days  Convert hours in minutes  Convert hours in seconds  Leave as is   Convert!  Output   Save  function displayOutput(text){ const outBox = document.getElementById('output'); outBox.textContent = ''; outBox.textContent = text; } function saveCSV(){ // console.log(newCSV) const blob = new Blob([newCSV], {type: 'text/plain'}); const inFileName = fileList[0].name const fileName = inFileName + '_toCSV.csv'; let newLink = document.createElement('a'); newLink.download = fileName; newLink.href = window.webkitURL.createObjectURL(blob); // newLink.style.display = 'none'; // document.body.appendChild(newLink); newLink.click(); } const tdCheckBox = document.getElementById('convertTimeDay'); const tmCheckBox = document.getElementById('convertTimeMin'); const tsCheckBox = document.getElementById('convertTimeSec'); const fileSelector = document.getElementById('file-selector'); const fileNameBox = document.getElementById('fileBox'); fileSelector.addEventListener('change', (event) = { window.fileList = event.target.files; fileNameBox.textContent = event.target.files[0].name }); const convertButton = document.getElementById('convert_button') convertButton.addEventListener('click',(event)={ var reader = new FileReader(); var header = 'id;ts_hour;id_tsloc;ix;iy;t;q;u;v;psfc;glw;gsw;hfx;lh;tsk;tslb(1);rainc;rainnc;clw\\n'; reader.onload = function(){ var infileName = window.fileList[0].name; var text = reader.result; var csv = header+text.split('\\n').slice(1).join('\\n').replace(/ \\s+/g,';'); // CSV and data manipulation var lines = csv.split('\\n'); var result = []; var headers = lines[0].split(';'); for(var i=1; i{ event.stopPropagation(); event.preventDefault(); // Style the drag-and-drop as a \"copy file\" operation. event.target.style.border = \"4px solid teal\"; event.target.style.color = \"teal\"; event.target.style.fontWeight = \"bold\"; event.dataTransfer.dropEffect = 'copy'; }); dropZone.addEventListener('dragleave',(event)={ event.stopPropagation(); event.preventDefault(); // Style the drag-and-drop as a \"copy file\" operation. event.target.style.border = \"3px solid\"; event.target.style.color = \"\"; event.target.style.fontWeight = \"normal\"; }); dropZone.addEventListener('drop', (event) = { event.stopPropagation(); event.preventDefault(); event.target.style.border = \"3px solid\"; event.target.style.fontWeight = \"normal\"; event.target.style.color = \"\"; window.fileList = event.dataTransfer.files; fileNameBox.textContent = fileList[0].name });   ","date":1645488000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645488000,"objectID":"c6e23a852df65b6be068fd45ac9ee398","permalink":"https://gabri.xyz/projects/tslist/","publishdate":"2022-02-22T00:00:00Z","relpermalink":"/projects/tslist/","section":"projects","summary":"online WRF tslist to csv converter","tags":["WRF"],"title":"Tslist converter","type":"projects"},{"authors":null,"categories":null,"content":"General introduction to planes and plotting  To know more about planes and plotting read Stereographic Projection Techniques for Geologists and Civil Engineers   In geology a basic plane can be rappresented by different parameters linked to the orentation of the plane in respect to the cardinal points and the inclination of the plane in respect to the horizontal. The first parameter can be expressed in different ways but the main two are:\n Strike Dip direction  The second parameter on the other hand is defined only by one value defined as the Dip angle\nThe strike and dip direction of a plane are strictly linked.\n The strike is defined as the direction given by the intersection line between the given plane and a horizontal plane. The dip direction is the angle orthogonal to the strike.\n As an example a plane with 90° of strike has a dip direction of 180°. To visualize this relationship we can use the right hand rule:\nthe thumb coincides with the direction while the direction of fingers (palm facing downward) the dip direction of the plane.\nThis way with a value of strike = 90° we can extrapolate that the plane has a direction of 90° and it is dipping South (180°).\nThese basic parameters can be very usefull in geology to understand the general orientation of rock strata encountered on the field and so their overall geometry.\nPlotting planes To efficiently analyze the gathered data we can use stereoplots. These kind of plot are obtained as the equatorial projection of the intersection of a plane or line typically with the southern hemisphere of a sphere. In this way planes are rappresented as curves while lines as dots. When we have a high number of planes some patterns can emerge such as planes dipping in the same general direction and with similar inclination angles. This grouping is called a set of planes. On stereoplots defining sets can be very difficult especially if there are lots of sets and planes with different orientation. To semplify the view usually poles are used1.\nmplstereonet  To know more about mplstereonet go to https://mplstereonet.readthedocs.io/en/latest/mplstereonet.html   Using the mplstereonet library we can plot geological data as lines or poles by giving the appropriate strike and dip measurements of the given plane. The process to generate random planes is not that complex since the values that need to be generated are only two.\nFirst we need to install the two main libraries: mplstereonet and numpy using pip:\npip install mplstereonet numpy  Now we can start scripting. Let\u0026rsquo;s plot a simple plane with 90° strike and 60° dip angle.\nimport mplstereonet as mpl import matplotlib.pyplot as plt strike = 90 #strike value dip = 60 #dip value fig = plt.figure('Stereoplot') #initialize a figure with the name 'Stereoplot' ax = fig.add_subplot(111,projection='stereonet') #add plot in the figure with the stereonet projection ax.grid() #add a grid ax.plane(strike,dip,'k-') #plot the plane data as a black line ax.pole(strike,dip,'kx') #plot the corresponding pole of the plane as a black x plt.show() #show the plot   Example 1 result  Adding random measurements can be archived using numpy random library\nimport numpy.random as r import mplstereonet as mpl import matplotlib.pyplot as plt strike = r.randint(0,361) #random strike value (range from min to max-1) dip = r.randint(0,91) #random dip value print(f'strike:{strike}, dip dir:{(strike+90)%360}, dip:{dip}') #print string to display the strike, dip dir and dip values. ''' The dip direction can be calculated by adding 90°and applying the reminder operator % to constrain the result to max 360. For example if the strike is 300 the dip direction will be 30° because 390%360 = 30. ''' fig = plt.figure('Stereoplot') #initialize a figure with the name 'Stereoplot' ax = fig.add_subplot(111,projection='stereonet') #add plot in the figure with the stereonet projection ax.grid() #add a grid ax.plane(strike,dip,'k-') #plot the plane data as a black line ax.pole(strike,dip,'kx') #plot the corresponding pole of the plane as a black x plt.show() #show the plot  The plot will be similar to the figure of the first examlpe but with a random value of strike and dip angle.\nIf we want more than one plane we can create a numpy array of random values that can be plotted. This can be accomplished by modifying the lines\nstrike = r.randint(0,361,5) #5 random strike values (range from min to max-1) dip = r.randint(0,91,5) #5 random dip values  matplotlib is able to unpack and plot the different strike;dip pairs from the two lists.\nA more complex approach is by introducing the concept of plane set. We need a number of planes with the same general orientation and inclination. To do this we can:\n Define a random \u0026ldquo;generator\u0026rdquo; plane. This will define the direction and dip of the set Generate random data based on the generator direction and dip  To give the set a more \u0026ldquo;natural feeling\u0026rdquo; we can use a random number given by a normal distribuition with:\n$$\\mu = \\text{strike} \\text{ or } \\mu = \\text{dip} $$\nand random $\\sigma^2$.\nimport numpy as np import matplotlib.pyplot as plt import mplstereonet as mpl def random_plane_gen(sets=1, n_planes=10): r_s = np.random.randint(0,361,sets) #random strike r_dip = np.random.randint(0,91,sets) #random dip r_std = np.random.randint(5,20,sets) #random sigma^2 planes_dict = {x:{'s':0,'d':0} for x in range(sets)} ''' We can use dictionaries to be more tidy. For every set there is an entry 0: + s: 0 + d: 0 1: + s: 0 + d: 0 that then can be filled: 0: + s: 120 + d: 20 1: + s: 200 + d: 33 ''' for nset,s,d,std in zip(list(range(sets)),r_s,r_dip,r_std): #take only the absolute values of n_planes random values with center s and given sigma^2 rounded to 2 decimals planes_dict[nset]['s'] = np.abs(np.round(np.random.normal(s,std,n_planes),2)) planes_dict[nset]['d'] = np.abs(np.round(np.random.normal(d,std,n_planes),2)) return planes_dict random_set = random_plane_gen() print(random_set) #print dict def plane_plot(planes_dict,show_planes=1,show_poles=0): #plot with different colors depending on the set (0:red, 1:green, ...) set_color = ['r','g','b','k','m','c'] fig = plt.figure('Stereonet') ax = fig.add_subplot(111, projection='stereonet') for sets in planes_dict: #for every set present in the dict for i in range(len(planes_dict[sets]['s'])): if show_planes: ax.plane(planes_dict[sets]['s'][i], planes_dict[sets]['d'][i], f'{set_color[sets]}-') if show_poles: ax.pole(planes_dict[sets]['s'][i], planes_dict[sets]['d'][i], f'{set_color[sets]}o') ax.grid() plt.show() plane_plot(random_set)      Example 4 results. Below plotted 2 sets of different planes \n  Poles are artificial lines normal to the surface of a given plane.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1636675200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636675200,"objectID":"46aeda8a256519f639ab2e5832eb2514","permalink":"https://gabri.xyz/post/pydip/random-planes/","publishdate":"2021-11-12T00:00:00Z","relpermalink":"/post/pydip/random-planes/","section":"post","summary":"In geology a basic plane can be rappresented by different parameters linked to the orentation of the plane in respect to the cardinal points and the inclination of the plane in respect to the horizontal.","tags":["Structural geology","Python"],"title":"Generate and plot random planes using python","type":"post"},{"authors":null,"categories":null,"content":"Pydip is a python program with the main objective to give a stereoplot reading practice platform by generating random planes, folds, faults and focal mechanisms.\nAs a secondary future objective, for now not implemented, the software will be able to plot and elaborate structural measurements obtained on the field (similar to Stereonet).\nThe plots are generated with mplstereonet library.\nCapabilities: Generate multiple random sets of planes   The program chooses a random dip direction and angle for every set and depending on that plane the planes will be generated with a normal distribuition with a random std value.\nThe parameters that can be tweaked are:\n Number of sets Number of planes Plot planes and/or poles  Generate multiple random sets of folds   The program can generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nThe parameters that can be tweaked are:\n Number of sets of folds Number of planes for every fold limb Plot limb planes and/or poles Plot plane axis and/or hinge line  Generate random focal mechanisms   Data table view and selection   Import and plot imported data Planned features:  Faults Better selection options Better import functions Statistics module 3D viewer for plotted structures  ","date":1619827200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619827200,"objectID":"377ad74bcfe4e5a470539e885ab03074","permalink":"https://gabri.xyz/projects/pydip/","publishdate":"2021-05-01T00:00:00Z","relpermalink":"/projects/pydip/","section":"projects","summary":"Python program to generate random structural data such as planes, folds, faults and focal mechanisms.","tags":["Structural geology"],"title":"Pydip","type":"projects"},{"authors":null,"categories":null,"content":"The premise RocLab is a very useful piece of free software written in 2011 for determining rock mass strength parameters, based on the generalized Hoek-Brown failure criterion (Hoek et al. 2002). The main problem is that it is discontinued and the only version is available for windows. With this project I want to archive the same objective as RocLab\u0026rsquo;s using python to increase the overall accessibility of the program and improve the plot\u0026rsquo;s interfaces (thanks to matplotlib).\nCapabilities  Calculate Hoek-Brown criterion parameters Calculate Rock mass parameters ($\\sigma_t$, $\\sigma_c$, $\\sigma_{cm}$, $E_{rm}$) Calculate $\\sigma_{3}^{max}$ based on different applications (e.g tunnels) Calculate Mohr-Coulomb parameters (c and $\\phi$) Plot H-B and M-C envelope. Plot failure mohr circle and calculate the $\\sigma_{1}^{max}$ value.    Main view with the HB crit plot   Main view with the HB and MC crit plot   Secondary veiw with the Mohr-Coulomb failure circle \nFuture additions:  Tabulated list values for D Tabulated list values for $m_i$ Import data Export data  ","date":1612915200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612915200,"objectID":"552957397c04c94c61d3afdb91ca226b","permalink":"https://gabri.xyz/projects/rocpy/","publishdate":"2021-02-10T00:00:00Z","relpermalink":"/projects/rocpy/","section":"projects","summary":"Roclab inspired python program","tags":["Geotechnics"],"title":"Rocpy","type":"projects"},{"authors":null,"categories":null,"content":"The premise Pyseismic is a simple python interface created to visualize and process seismic traces based on the Obspy package.\nThe aim of this project is to create a simple alternative to the more complex and costly Visual SUNT that can be used to do basic taks without the need to buy professional softwares. Since is entirely written in pyhon it can be run on every platform (Visual SUNT is only on Windows D:).\nCapabilities For now there are very few functions available (the essentials). In particular seispy can:\n Read and plot with matplotlib seismic traces from files supported on Obspy      Apply FFT analysis on single or multiple traces      Basic filtering (band pass, low and high pass)      First break picking with options of live dromochrome plot.     Future capabilities As it is this software is very bare bones but I have plans to expand it with more features such as:\n Automatic first break Trace muting More precise import options (as for now it relies on the autodetect features of Obspy) Simple stratigraphic model reconstruction (from dromochrome elaboration) Delaytime and GRM applications SRCS Focal mechanism reconstruction  ","date":1608422400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608422400,"objectID":"4914438c64f7127d2d21db54e34960c4","permalink":"https://gabri.xyz/projects/pyseismic/","publishdate":"2020-12-20T00:00:00Z","relpermalink":"/projects/pyseismic/","section":"projects","summary":"Visual SUNT style application written in python.","tags":["Geophysics"],"title":"Pyseismic","type":"projects"},{"authors":null,"categories":null,"content":"The premise This project was a request aimed to find a way to prepare different 3D models, in particular artificial slopes, and calculate the difference between two reconstructions after a given event directly in metashape without using external programs.\nIn particular the set of scripts needed to achive the following tasks:\n Apply different masks for different sets of photos. Count the total number of markers detected in all of the uploaded photos. The number of markers needed to be in total always 135. Cut the resulting point clouds with constant dimensions and automatically apply a rotatation to make the plane horizontal. Calculate the difference between two meshes. To make sure that the difference operation was applied properly the two chunks need to be aligned and the models need to be rotated flat and cropped.    Input image example     Reconstructed slope before and after the event \n Summary Mask application The model is constructed using photos that capture a different angle of the artificial plane. The first step is to isolate the relevant slope information by masking the parts of the slope that are not needed for the reconstruction (e.g. the container). To do this different masks were created to mask specific parts present in different sets of photos. The pairing is as follows:\n photo 1 $\\rightarrow$ '' Links_Initial.jpg '' photo 2 to 21 $\\rightarrow$ '' Links_Regular.jpg '' photo 22 $\\rightarrow$ '' Midden_Initial.jpg '' photo 23 to 42 $\\rightarrow$ '' Midden_Regular.jpg '' photo 43 $\\rightarrow$ '' Rechts_Initial.jpg '' photo 44 to 63 $\\rightarrow$ \u0026lsquo;\u0026lsquo;Rechts_Regular.jpg '\u0026rsquo;  This process was accomplished by writing the mask.py script.\nMarker count For each model there is a known fixed number of total markers that need to be detected (135). The objective of this script is to count the total amount of markers detected in the model and print if there are less than 135. This check is done to see if the automatic markers present for each markers are somehow cropped or masked out.\nThe check process was automated using the check_markers.py script\nCut and rotate the model point cloud To apply correctly the difference between the two models they both need to have the same size, position and rotation. To do this it was decided to rotate first the psarse cloud model and then resize the bounding box to a determined size. To do this the following process was defined:\n Define the region size Find the minimum and maximum (for both x and y) points inside the bounding box and calculate the center (as the midpoint of points at opposite corners). Translate the points on the same height of the center point Set these points as tranform reference Update transform (and so rotate the points) Resize the bounding box  To accurately rotate the model the plane needs to fit in the bounding box as tightly as possibile and so the z value need to be low. Too low z values can crop too much of the plane (since the plane has a certain inclination angle) and so the rotation won\u0026rsquo;t be as precise.\nThis process is archived by using the region_size.py script.\nMesh difference Instead of caluclating the difference of the two meshes a quicker is to convert the meshes in Digital Elevation Models and then apply a per pixel difference.\n Final workflow We can summarize the developed metashape workflow as follows:\n   This workflow is resonably fast and has the possibility to batch the processes to further automate the workflow.\n     Reconstructed DEM of the slope before and after the event    DEM difference  ","date":1606262400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606262400,"objectID":"63ee11348e5c5f03ac8968abd63f4c71","permalink":"https://gabri.xyz/projects/auto-slope/","publishdate":"2020-11-25T00:00:00Z","relpermalink":"/projects/auto-slope/","section":"projects","summary":"Compute the difference between two referenced slopes reconstructed in Metashape Professional.","tags":["Photogrammetry"],"title":"Automatic processing for referenced slopes","type":"projects"},{"authors":null,"categories":null,"content":"The premise This idea came to mind while doing university field trips in which we learned how to use a geological compass and how to take measurements (e.g. dip direction/dip) needed for geological interpretation and reconstruction of planes, folds etc.. A lot of time is lost, and error is introduced, in saving the appropriate txt file with the appropriate format and tabulation. This project has the aim to create a low-cost, open-source electronic geological compass that reduces the time needed to take a measurement, write it down and afterwards rewrite in a txt to be used in other programs (Stereonet, wintensor\u0026hellip;) by creating a tool that works as a normal compass but can save the measurements locally in the appropriate files for different softwares.\nThe planned compass features are:\n Measure dip and dip direction of a plane Measure strike slip, trend and plunge Quick profile switch (direction/dip, trend/plunge etc..) Automatic txt files save Calibration features Data elaboration software (pydip)  Components list The Electronic Compass components are searched to be the most cost-effective and easy to solder available that I could find. I provide the links from where the components are purchased but some are europe based (mostly Germany) so check if worldwide shipping is convenient or not.\n   Component Name Quantity Price Link     Adafruit adalogger M0 x1 26€ ThePiHut   GY-61 ADXL335 acceletometer x1 6.79€ AZ-Delivery   128x32 Oled display x1 6.29€ AZ-Delivery   GY-271 QMC5883L magnetometer x1 5.79€ AZ-Delivery   SD card x1 may vary Amazon   1200mAh 3.7V LiPo battery x1 5.36€ Welectron   Potentiometer x1 ? Amazon   Buttons x? ? Amazon    Software used To have a truly open-source project the software used is 100% free and open-source from the CAD project files to the software used to code and flash the code on the adalogger chip.\n   Type Software program Source link     CAD FreeCAD FreeCAD   Electronics KiCad EDA KiCad   Code environment and upload ArduinoIDE Arduino    Licences Since the E.C. project covers hardware and software licences that cover both are necessary. You can find the choosen licences in the \u0026ldquo;Licences folder\u0026rdquo; in PDF and .txt format.\n   Type License name Source link     Software GNU General Public License v3.0 or later SPDX   Hardware CERN-OHL-S-2.0 or any later version OHWR    The copyrights to both hardware and software are explicited in the copyright.pdf and copyright.md files and the original copies are stored in the License folder. If you want to apply any kind of change you always need to log it in the changes.md file and include all the original source and copyright files as per licences.\n","date":1596585600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596585600,"objectID":"d3d429f5ff1cef034b23adc46485194a","permalink":"https://gabri.xyz/projects/ec/","publishdate":"2020-08-05T00:00:00Z","relpermalink":"/projects/ec/","section":"projects","summary":"The electronic compass has the aim to create a low-cost, open-source electronic geological compass.","tags":["Geotechnics","Structural geology","Ec"],"title":"Electronic Compass","type":"projects"},{"authors":null,"categories":null,"content":"The premise The computing power of modern technologies and their rapid development gave the possibility to reconstruct 3D digital objects precisely and rapidly from the real world, increasing the possibility of their conservation and sharing. There are three different types of reconstruction techniques: photogrammetry, 3D scan and CT scan or tomography. These three methods are based on the fundamental concept of obtaining, interpreting, and measuring surface and objects properties without needing a direct contact with the object. This project gives a more in-depth look of photogrammetry, in particular the modern technique defined as Structure from Motion, applied to centimetric macroinvertebrate fossils. Photogrammetry is the most accessible and cost-effective method of the three. The project was entirely developed during the COVID-19 sanitary emergency using already available or easily obtainable equipment. As a second aim and long-term objective, the thesis works as a guide for further experimentation and automation of the process of data capture and processing and to create a digital palaeontological archive that can be used for online accurate analysis of specimens.\nProcedures In photogrammetry the digital reconstruction of an object is given by specialized software that can approximate the position of the photos relative to the object and its structure by capturing photos of different perspectives of the object. Since image capturing can be done with a passive sensor, photogrammetry is the most popular and diffused method of reconstruction. Furthermore, it can produce a textured model, process not always possible in 3D and CT scans. The software used in this project is Agisoft Metashape Professional because it has many tools, and it is efficiently optimized. Two main steps compose the reconstruction process:\n Image capture Computer processing.  The first step consists in a preliminary phase in which lights, camera and the specimen are positioned and the distance between the camera and the specimen is measured. Then, only when the user is certain that the specimen is in a stable fixed position the capturing process starts. The simplest capturing procedure consists in fixing the position of the camera and rotate the specimen on one axis. The angle of rotation needs to be small enough to have an 80% overlap between images. Lighting of the specimen needs to be diffused and multidirectional to avoid sharp shadows. The background needs to be featureless to avoid reconstruction errors.\nThe second step consists in importing the images into the software, process them and construct the final model. The processing in the software is divided in five main phases:\n Image masking Image alignment Formation of a dense cloud Meshing Texturing.  When the model is complete, it can be scaled to the real-world equivalent. In this way the measures taken on the model correspond to the real-world equivalent. For the processes that cannot be done inside the Agisoft Metashape software we proposed python codes precisely written for automatically completing some tasks (e.g. conversion of raw image files in jpg).\nFor the process of image capture, a Nikon D3100 reflex camera was used, in order to better control the focus, ISO and focal ratio parameters and used macro rings, in particular the 12+20mm combination, to capture the most minute details of the specimen. In order to avoid sharp shadows and give a homogeneous lighting to the specimens, we used two table lamps with diffused light. The background was black to increment the contrast with the specimen and help to differentiate the background from the object. To maintain the specimens in a fixed position crocodile-clips were used for a constant and strong grip. Each model was composed by 200 photos and took from 2 to 3 hours to complete. The model reconstruction process was applied to six specimens. Five of them were extracted from recent and Pleistocenic sediments in Solanto (Palermo, Italy), the former belonging to the Sintema di Marsala, precisely to the lithofacies of Calcareniti di Palermo. The sixth one was collected from recent sediments in California (USA). The classification was done by observing the macroscopic characteristics of the specimens and was aided by different texts.\nResults Spondylus gaederopus Linnaeus 1758   Venus verrucosa Linnaeus 1758   Pseudochama gryphina (Lamarck, 1819)   Haliotis tuberculata Linnaeus 1758   Dendraster excentricus (Eschscholtz, 1831)   Conclusions In general, photogrammetric programs have their limitations and cannot reconstruct smooth, reflective, and transparent surfaces. There were in fact some difficulties in reconstructing some characteristics of the studied specimens. The pallial line for example is not present in the models because it is hardly detectable also in the photos. The internal parts for some specimens also were not completely reconstructed because they were smooth and reflective. On the other hand, problems linked to the geometry of a particular specimen were easily resolved by modifying the alignment options. In the end, the results obtained from the application of photogrammetry on these six fossils demonstrate that this is a valid and accessible technique that can give accurate models. I hope in the future that this method of obtaining precise models very quickly can overcome the difficulties encountered and that it can be adopted as a standard to create an always-accessible repository where models can be shared and possibly 3D printed.\n","date":1587600000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587600000,"objectID":"7a929107d19d1b8a695d60db9db4c42b","permalink":"https://gabri.xyz/projects/fossils/","publishdate":"2020-04-23T00:00:00Z","relpermalink":"/projects/fossils/","section":"projects","summary":"Methods applied to obtain 3D accurate models of fossils using photogrammetry.","tags":["Paleontology","Photogrammetry"],"title":"3D paleontological objects","type":"projects"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://gabri.xyz/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]