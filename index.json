[{"authors":null,"categories":null,"content":"About this site This site is meant to function as a place to organize and archive my projects in a single place. Too many times I\u0026rsquo;ve started a project and never finished it because I\u0026rsquo;ve forgotten about it or it became too messy to start all over again. By creating this site I hope to build a solid structure as future reference, use it to document the progress over time and help me reconsider and/or finish suspended projects. The site was built in Go Hugo, an open source static site generator available under the Apache Licence 2.0.\nAbout me I\u0026rsquo;m a 23 years old geology student with a passion for science, technology, woodworking, nature and photography. I\u0026rsquo;ve always been fascinated by the complexity of our Earth and during my academic course I found (and still find) endless possibilities of applying modern technology and coding to many geological concepts. I love to get my hands dirty, fix and dissasemble objects to try to understand how different parts work and relate to eachother. I am always eager to learn something new techniques, tools, softwares and to create new tools to assist during my learning process.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://gabri.xyz/author/gabriele-benedetti/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/gabriele-benedetti/","section":"authors","summary":"About this site This site is meant to function as a place to organize and archive my projects in a single place. Too many times I\u0026rsquo;ve started a project and never finished it because I\u0026rsquo;ve forgotten about it or it became too messy to start all over again.","tags":null,"title":"Gabriele Benedetti","type":"authors"},{"authors":null,"categories":null,"content":"The premise This project has the main objective to create an open-source compatible processing pipeline to automatically elaborate Ground Penetrating Radar (GPR) data to output a GPR volume in VTK format. Once ready, the volume then can be used to intuitively localize, identify and analyze in 3D space buried objects in the top most layer of soil (in this case up to a depth of 1m).\nGPR Data GPR is a relatively new indirect non-invasive geophysical exploration method that can be used to acquire subsurface data up to a depth of 50m1. This technique is based on the capture of reflected high frequency electromagnetic signals emitted from a controlled source. The contrast of electrical properties in the soil given by presence of anomalous objects, cavities, sedimentary structures, change in lithology or in water contents induce a variation in the signal\u0026rsquo;s propagation velocity thus producing a return pulse that is recorded. By visualizing the acquired data it is then possible to define the presence of perturbations across the medium and carry out different interpretations.  Schematic representation on how the GPR works (image soruce). \nGPR data is recorded in traces grouped and organized in segments saved as SEGY files, every trace represents a point in space where the pulse has been emitted and the return signals recorded. A segment can be comprised of multiple sub-segments where the start and end (markers) can be defined during the recording or manually in the pre-processing phase. Markers can also be used to highlight points of interest encountered during the acquisition. These and any many other types of information are stored in the SEGY file header of both the segment and the single trace.\n Example image of a typical GPR recording.  Processing pipeline  Schematic processing pipeline.  The processing pipline adopted to elaborate and visualize the data is composed by a pre-processing and processing phase. Once the data is downloaded the user needs to take in to account a series of characteristics. Firstly it is necessary to read the header to define the geometry of the survey using the trace position information and the presence of markers. If these types of information are present or not required, the pre-processing step can be skipped and the data directly used.\nFor every segment/sub-segment the returning signal data needs to be read and every trace has to be processed to a certain degree. It is better not to use the raw data or heavily processed data since the interpretation of both can result difficult. Signal noise can hide the objects or lead to wrong object geometry reconstruction and on the other hand too much processing/filtering can mask some objects or create artifacts also causing interpretation problems.\nOnce the header information is gathered and the signal data processed it is possible to create a uniform 3D point cloud. This is achieved by dividing the traces in multiple intervals (integration depth) and linearly interpolating on a 2D depth slice the mean trace intensities in the given depth interval2. Although this approach effectively reduces the number of samples along the Z axis, thus lowering the vertical resolution of the model, it improves the overall quality of the data and highlights the presence of anomalies.\nThe intensity value of each point is then assigned to a cell (voxel) creating a GPR volume.\nResults This pipeline was applied to data acquired in Piazza della Scienza (Milan) to identify objects in the first meter of soil, important to the square\u0026rsquo;s future depaving and redesign project. The final computed GPR volume is 1m deep with a resolution of 600x600 cells giving a final grid resolution of 600x600x100. The grid, volume creation and final analysis were achieved using Pyvista. The code and data used to apply the different steps is available as a jupyter notebook. For a more in depth review of the process and more images a report in PDF format is available.\n  Best case scenario\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The depth slice is an \u0026ldquo;image\u0026rdquo; of (nx;ny) pixels where for each pixel the respective calculated value is assigned. The absolute interpolated value was used, but squaring too is a viable option.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1655856000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655856000,"objectID":"9d03a724ba13d4051f62f4ad570c4935","permalink":"https://gabri.xyz/projects/gpr/","publishdate":"2022-06-22T00:00:00Z","relpermalink":"/projects/gpr/","section":"projects","summary":"Pipeline to create GPR 3D volumes with Python.","tags":["Geophysics"],"title":"GPR 3D volume","type":"projects"},{"authors":null,"categories":null,"content":"TS lists are a type of output files that are produced by WRF during a simulation to register the calculated values in specific coordinates. The raw output format of these files is not universal and it makes importing this kind of data a big hassle in other programs (such as excel). To contrast this problem I created this page that can be used to convert any TSLISTS in a properly formatted csv file and if necessary do some simple conversion and calculations (such as converting the time column from hours to days).\nThis converter uses javascript to import and manipulate the data. Everything is done locally so it works even offline if the page is saved.\n NOTE: For now batch conversion is not supported. You need to convert one file at a time.\n Todo  Batch conversions Mean calculations over time User defined separator   Converter   File(s) size  html { font-family: sans-serif; } div#drop_box { height: 400px; width: 400px; border: 3px solid; display: flex; justify-content: center; flex-direction: column; align-items: center; border-radius: 4px; } input[type='file'] { color: transparent; } button, input[type='file']::file-selector-button { background-color: #4CAF50; /* Green */ border: none; color: white; padding: 10px 15px; text-align: center; text-decoration: none; display: inline-block; font-size: 20px; border-radius: 3px; } pre { display: -webkit-box; -webkit-line-clamp: 10; -webkit-box-orient: vertical; } .dropBox{ font-size: 1.15em; } .formCtrl{ font-size: 1.15em; font-weight: normal; line-height: 1.1; display: grid; grid-template-columns: 1em auto; gap: 0.5em; } input[type='radio']{ width: 1em; height: 1em; }   Input options or  Drop to upload  Drop here  Chosen file/s  Conversion options Time options Convert hours in days  Convert hours in minutes  Convert hours in seconds  Leave as is   Convert!  Output   Save  function displayOutput(text){ const outBox = document.getElementById('output'); outBox.textContent = ''; outBox.textContent = text; } function saveCSV(){ // console.log(newCSV) const blob = new Blob([newCSV], {type: 'text/plain'}); const inFileName = fileList[0].name const fileName = inFileName + '_toCSV.csv'; let newLink = document.createElement('a'); newLink.download = fileName; newLink.href = window.webkitURL.createObjectURL(blob); // newLink.style.display = 'none'; // document.body.appendChild(newLink); newLink.click(); } const tdCheckBox = document.getElementById('convertTimeDay'); const tmCheckBox = document.getElementById('convertTimeMin'); const tsCheckBox = document.getElementById('convertTimeSec'); const fileSelector = document.getElementById('file-selector'); const fileNameBox = document.getElementById('fileBox'); fileSelector.addEventListener('change', (event) = { window.fileList = event.target.files; fileNameBox.textContent = event.target.files[0].name }); const convertButton = document.getElementById('convert_button') convertButton.addEventListener('click',(event)={ var reader = new FileReader(); var header = 'id;ts_hour;id_tsloc;ix;iy;t;q;u;v;psfc;glw;gsw;hfx;lh;tsk;tslb(1);rainc;rainnc;clw\\n'; reader.onload = function(){ var infileName = window.fileList[0].name; var text = reader.result; var csv = header+text.split('\\n').slice(1).join('\\n').replace(/ \\s+/g,';'); // CSV and data manipulation var lines = csv.split('\\n'); var result = []; var headers = lines[0].split(';'); for(var i=1; i{ event.stopPropagation(); event.preventDefault(); // Style the drag-and-drop as a \"copy file\" operation. event.target.style.border = \"4px solid teal\"; event.target.style.color = \"teal\"; event.target.style.fontWeight = \"bold\"; event.dataTransfer.dropEffect = 'copy'; }); dropZone.addEventListener('dragleave',(event)={ event.stopPropagation(); event.preventDefault(); // Style the drag-and-drop as a \"copy file\" operation. event.target.style.border = \"3px solid\"; event.target.style.color = \"\"; event.target.style.fontWeight = \"normal\"; }); dropZone.addEventListener('drop', (event) = { event.stopPropagation(); event.preventDefault(); event.target.style.border = \"3px solid\"; event.target.style.fontWeight = \"normal\"; event.target.style.color = \"\"; window.fileList = event.dataTransfer.files; fileNameBox.textContent = fileList[0].name });   ","date":1645488000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645488000,"objectID":"c6e23a852df65b6be068fd45ac9ee398","permalink":"https://gabri.xyz/projects/tslist/","publishdate":"2022-02-22T00:00:00Z","relpermalink":"/projects/tslist/","section":"projects","summary":"online WRF tslist to csv converter","tags":["WRF"],"title":"Tslist converter","type":"projects"},{"authors":null,"categories":null,"content":"General introduction to planes and plotting  To know more about planes and plotting read Stereographic Projection Techniques for Geologists and Civil Engineers   In geology a basic plane can be rappresented by different parameters linked to the orentation of the plane in respect to the cardinal points and the inclination of the plane in respect to the horizontal. The first parameter can be expressed in different ways but the main two are:\n Strike Dip direction  The second parameter on the other hand is defined only by one value defined as the Dip angle\nThe strike and dip direction of a plane are strictly linked.\n The strike is defined as the direction given by the intersection line between the given plane and a horizontal plane. The dip direction is the angle orthogonal to the strike.\n As an example a plane with 90° of strike has a dip direction of 180°. To visualize this relationship we can use the right hand rule:\nthe thumb coincides with the direction while the direction of fingers (palm facing downward) the dip direction of the plane.\nThis way with a value of strike = 90° we can extrapolate that the plane has a direction of 90° and it is dipping South (180°).\nThese basic parameters can be very usefull in geology to understand the general orientation of rock strata encountered on the field and so their overall geometry.\nPlotting planes To efficiently analyze the gathered data we can use stereoplots. These kind of plot are obtained as the equatorial projection of the intersection of a plane or line typically with the southern hemisphere of a sphere. In this way planes are rappresented as curves while lines as dots. When we have a high number of planes some patterns can emerge such as planes dipping in the same general direction and with similar inclination angles. This grouping is called a set of planes. On stereoplots defining sets can be very difficult especially if there are lots of sets and planes with different orientation. To semplify the view usually poles are used1.\nmplstereonet  To know more about mplstereonet go to https://mplstereonet.readthedocs.io/en/latest/mplstereonet.html   Using the mplstereonet library we can plot geological data as lines or poles by giving the appropriate strike and dip measurements of the given plane. The process to generate random planes is not that complex since the values that need to be generated are only two.\nFirst we need to install the two main libraries: mplstereonet and numpy using pip:\npip install mplstereonet numpy  Now we can start scripting. Let\u0026rsquo;s plot a simple plane with 90° strike and 60° dip angle.\nimport mplstereonet as mpl import matplotlib.pyplot as plt strike = 90 #strike value dip = 60 #dip value fig = plt.figure('Stereoplot') #initialize a figure with the name 'Stereoplot' ax = fig.add_subplot(111,projection='stereonet') #add plot in the figure with the stereonet projection ax.grid() #add a grid ax.plane(strike,dip,'k-') #plot the plane data as a black line ax.pole(strike,dip,'kx') #plot the corresponding pole of the plane as a black x plt.show() #show the plot   Example 1 result  Adding random measurements can be archived using numpy random library\nimport numpy.random as r import mplstereonet as mpl import matplotlib.pyplot as plt strike = r.randint(0,361) #random strike value (range from min to max-1) dip = r.randint(0,91) #random dip value print(f'strike:{strike}, dip dir:{(strike+90)%360}, dip:{dip}') #print string to display the strike, dip dir and dip values. ''' The dip direction can be calculated by adding 90°and applying the reminder operator % to constrain the result to max 360. For example if the strike is 300 the dip direction will be 30° because 390%360 = 30. ''' fig = plt.figure('Stereoplot') #initialize a figure with the name 'Stereoplot' ax = fig.add_subplot(111,projection='stereonet') #add plot in the figure with the stereonet projection ax.grid() #add a grid ax.plane(strike,dip,'k-') #plot the plane data as a black line ax.pole(strike,dip,'kx') #plot the corresponding pole of the plane as a black x plt.show() #show the plot  The plot will be similar to the figure of the first examlpe but with a random value of strike and dip angle.\nIf we want more than one plane we can create a numpy array of random values that can be plotted. This can be accomplished by modifying the lines\nstrike = r.randint(0,361,5) #5 random strike values (range from min to max-1) dip = r.randint(0,91,5) #5 random dip values  matplotlib is able to unpack and plot the different strike;dip pairs from the two lists.\nA more complex approach is by introducing the concept of plane set. We need a number of planes with the same general orientation and inclination. To do this we can:\n Define a random \u0026ldquo;generator\u0026rdquo; plane. This will define the direction and dip of the set Generate random data based on the generator direction and dip  To give the set a more \u0026ldquo;natural feeling\u0026rdquo; we can use a random number given by a normal distribuition with:\n$$\\mu = \\text{strike} \\text{ or } \\mu = \\text{dip} $$\nand random $\\sigma^2$.\nimport numpy as np import matplotlib.pyplot as plt import mplstereonet as mpl def random_plane_gen(sets=1, n_planes=10): r_s = np.random.randint(0,361,sets) #random strike r_dip = np.random.randint(0,91,sets) #random dip r_std = np.random.randint(5,20,sets) #random sigma^2 planes_dict = {x:{'s':0,'d':0} for x in range(sets)} ''' We can use dictionaries to be more tidy. For every set there is an entry 0: + s: 0 + d: 0 1: + s: 0 + d: 0 that then can be filled: 0: + s: 120 + d: 20 1: + s: 200 + d: 33 ''' for nset,s,d,std in zip(list(range(sets)),r_s,r_dip,r_std): #take only the absolute values of n_planes random values with center s and given sigma^2 rounded to 2 decimals planes_dict[nset]['s'] = np.abs(np.round(np.random.normal(s,std,n_planes),2)) planes_dict[nset]['d'] = np.abs(np.round(np.random.normal(d,std,n_planes),2)) return planes_dict random_set = random_plane_gen() print(random_set) #print dict def plane_plot(planes_dict,show_planes=1,show_poles=0): #plot with different colors depending on the set (0:red, 1:green, ...) set_color = ['r','g','b','k','m','c'] fig = plt.figure('Stereonet') ax = fig.add_subplot(111, projection='stereonet') for sets in planes_dict: #for every set present in the dict for i in range(len(planes_dict[sets]['s'])): if show_planes: ax.plane(planes_dict[sets]['s'][i], planes_dict[sets]['d'][i], f'{set_color[sets]}-') if show_poles: ax.pole(planes_dict[sets]['s'][i], planes_dict[sets]['d'][i], f'{set_color[sets]}o') ax.grid() plt.show() plane_plot(random_set)      Example 4 results. Below plotted 2 sets of different planes \n  Poles are artificial lines normal to the surface of a given plane.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1636675200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636675200,"objectID":"46aeda8a256519f639ab2e5832eb2514","permalink":"https://gabri.xyz/post/pydip/random-planes/","publishdate":"2021-11-12T00:00:00Z","relpermalink":"/post/pydip/random-planes/","section":"post","summary":"In geology a basic plane can be rappresented by different parameters linked to the orentation of the plane in respect to the cardinal points and the inclination of the plane in respect to the horizontal.","tags":["Structural geology","Python"],"title":"Generate and plot random planes using python","type":"post"},{"authors":null,"categories":null,"content":"Pydip is a python program with the main objective to give a stereoplot reading practice platform by generating random planes, folds, faults and focal mechanisms.\nAs a secondary future objective, for now not implemented, the software will be able to plot and elaborate structural measurements obtained on the field (similar to Stereonet).\nThe plots are generated with mplstereonet library.\nCapabilities: Generate multiple random sets of planes   The program chooses a random dip direction and angle for every set and depending on that plane the planes will be generated with a normal distribuition with a random std value.\nThe parameters that can be tweaked are:\n Number of sets Number of planes Plot planes and/or poles  Generate multiple random sets of folds   The program can generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).\nThe parameters that can be tweaked are:\n Number of sets of folds Number of planes for every fold limb Plot limb planes and/or poles Plot plane axis and/or hinge line  Generate random focal mechanisms   Data table view and selection   Import and plot imported data Planned features:  Faults Better selection options Better import functions Statistics module 3D viewer for plotted structures  ","date":1619827200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619827200,"objectID":"377ad74bcfe4e5a470539e885ab03074","permalink":"https://gabri.xyz/projects/pydip/","publishdate":"2021-05-01T00:00:00Z","relpermalink":"/projects/pydip/","section":"projects","summary":"Python program to generate random structural data such as planes, folds, faults and focal mechanisms.","tags":["Structural geology"],"title":"Pydip","type":"projects"},{"authors":null,"categories":null,"content":"The premise RocLab is a very useful piece of free software written in 2011 for determining rock mass strength parameters, based on the generalized Hoek-Brown failure criterion (Hoek et al. 2002). The main problem is that it is discontinued and the only version is available for windows. With this project I want to archive the same objective as RocLab\u0026rsquo;s using python to increase the overall accessibility of the program and improve the plot\u0026rsquo;s interfaces (thanks to matplotlib).\nCapabilities  Calculate Hoek-Brown criterion parameters Calculate Rock mass parameters ($\\sigma_t$, $\\sigma_c$, $\\sigma_{cm}$, $E_{rm}$) Calculate $\\sigma_{3}^{max}$ based on different applications (e.g tunnels) Calculate Mohr-Coulomb parameters (c and $\\phi$) Plot H-B and M-C envelope. Plot failure mohr circle and calculate the $\\sigma_{1}^{max}$ value.    Main view with the HB crit plot   Main view with the HB and MC crit plot   Secondary veiw with the Mohr-Coulomb failure circle \nFuture additions:  Tabulated list values for D Tabulated list values for $m_i$ Import data Export data  ","date":1612915200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612915200,"objectID":"552957397c04c94c61d3afdb91ca226b","permalink":"https://gabri.xyz/projects/rocpy/","publishdate":"2021-02-10T00:00:00Z","relpermalink":"/projects/rocpy/","section":"projects","summary":"Roclab inspired python program","tags":["Geotechnics"],"title":"Rocpy","type":"projects"},{"authors":null,"categories":null,"content":"The premise Pyseismic is a simple python interface created to visualize and process seismic traces based on the Obspy package.\nThe aim of this project is to create a simple alternative to the more complex and costly Visual SUNT that can be used to do basic taks without the need to buy professional softwares. Since is entirely written in pyhon it can be run on every platform (Visual SUNT is only on Windows D:).\nCapabilities For now there are very few functions available (the essentials). In particular seispy can:\n Read and plot with matplotlib seismic traces from files supported on Obspy      Apply FFT analysis on single or multiple traces      Basic filtering (band pass, low and high pass)      First break picking with options of live dromochrome plot.     Future capabilities As it is this software is very bare bones but I have plans to expand it with more features such as:\n Automatic first break Trace muting More precise import options (as for now it relies on the autodetect features of Obspy) Simple stratigraphic model reconstruction (from dromochrome elaboration) Delaytime and GRM applications SRCS Focal mechanism reconstruction  ","date":1608422400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608422400,"objectID":"4914438c64f7127d2d21db54e34960c4","permalink":"https://gabri.xyz/projects/pyseismic/","publishdate":"2020-12-20T00:00:00Z","relpermalink":"/projects/pyseismic/","section":"projects","summary":"Visual SUNT style application written in python.","tags":["Geophysics"],"title":"Pyseismic","type":"projects"},{"authors":null,"categories":null,"content":"The premise This project was a request aimed to find a way to prepare different 3D models, in particular artificial slopes, and calculate the difference between two reconstructions after a given event directly in metashape without using external programs.\nIn particular the set of scripts needed to achive the following tasks:\n Apply different masks for different sets of photos. Count the total number of markers detected in all of the uploaded photos. The number of markers needed to be in total always 135. Cut the resulting point clouds with constant dimensions and automatically apply a rotatation to make the plane horizontal. Calculate the difference between two meshes. To make sure that the difference operation was applied properly the two chunks need to be aligned and the models need to be rotated flat and cropped.    Input image example     Reconstructed slope before and after the event \n Summary Mask application The model is constructed using photos that capture a different angle of the artificial plane. The first step is to isolate the relevant slope information by masking the parts of the slope that are not needed for the reconstruction (e.g. the container). To do this different masks were created to mask specific parts present in different sets of photos. The pairing is as follows:\n photo 1 $\\rightarrow$ '' Links_Initial.jpg '' photo 2 to 21 $\\rightarrow$ '' Links_Regular.jpg '' photo 22 $\\rightarrow$ '' Midden_Initial.jpg '' photo 23 to 42 $\\rightarrow$ '' Midden_Regular.jpg '' photo 43 $\\rightarrow$ '' Rechts_Initial.jpg '' photo 44 to 63 $\\rightarrow$ \u0026lsquo;\u0026lsquo;Rechts_Regular.jpg '\u0026rsquo;  This process was accomplished by writing the mask.py script.\nMarker count For each model there is a known fixed number of total markers that need to be detected (135). The objective of this script is to count the total amount of markers detected in the model and print if there are less than 135. This check is done to see if the automatic markers present for each markers are somehow cropped or masked out.\nThe check process was automated using the check_markers.py script\nCut and rotate the model point cloud To apply correctly the difference between the two models they both need to have the same size, position and rotation. To do this it was decided to rotate first the psarse cloud model and then resize the bounding box to a determined size. To do this the following process was defined:\n Define the region size Find the minimum and maximum (for both x and y) points inside the bounding box and calculate the center (as the midpoint of points at opposite corners). Translate the points on the same height of the center point Set these points as tranform reference Update transform (and so rotate the points) Resize the bounding box  To accurately rotate the model the plane needs to fit in the bounding box as tightly as possibile and so the z value need to be low. Too low z values can crop too much of the plane (since the plane has a certain inclination angle) and so the rotation won\u0026rsquo;t be as precise.\nThis process is archived by using the region_size.py script.\nMesh difference Instead of caluclating the difference of the two meshes a quicker is to convert the meshes in Digital Elevation Models and then apply a per pixel difference.\n Final workflow We can summarize the developed metashape workflow as follows:\n   This workflow is resonably fast and has the possibility to batch the processes to further automate the workflow.\n     Reconstructed DEM of the slope before and after the event    DEM difference  ","date":1606262400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606262400,"objectID":"63ee11348e5c5f03ac8968abd63f4c71","permalink":"https://gabri.xyz/projects/auto-slope/","publishdate":"2020-11-25T00:00:00Z","relpermalink":"/projects/auto-slope/","section":"projects","summary":"Compute the difference between two referenced slopes reconstructed in Metashape Professional.","tags":["Photogrammetry"],"title":"Automatic processing for referenced slopes","type":"projects"},{"authors":null,"categories":null,"content":"The premise This idea came to mind while doing university field trips in which we learned how to use a geological compass and how to take measurements (e.g. dip direction/dip) needed for geological interpretation and reconstruction of planes, folds etc.. A lot of time is lost, and error is introduced, in saving the appropriate txt file with the appropriate format and tabulation. This project has the aim to create a low-cost, open-source electronic geological compass that reduces the time needed to take a measurement, write it down and afterwards rewrite in a txt to be used in other programs (Stereonet, wintensor\u0026hellip;) by creating a tool that works as a normal compass but can save the measurements locally in the appropriate files for different softwares.\nThe planned compass features are:\n Measure dip and dip direction of a plane Measure strike slip, trend and plunge Quick profile switch (direction/dip, trend/plunge etc..) Automatic txt files save Calibration features Data elaboration software (pydip)  Components list The Electronic Compass components are searched to be the most cost-effective and easy to solder available that I could find. I provide the links from where the components are purchased but some are europe based (mostly Germany) so check if worldwide shipping is convenient or not.\n   Component Name Quantity Price Link     Adafruit adalogger M0 x1 26€ ThePiHut   GY-61 ADXL335 acceletometer x1 6.79€ AZ-Delivery   128x32 Oled display x1 6.29€ AZ-Delivery   GY-271 QMC5883L magnetometer x1 5.79€ AZ-Delivery   SD card x1 may vary Amazon   1200mAh 3.7V LiPo battery x1 5.36€ Welectron   Potentiometer x1 ? Amazon   Buttons x? ? Amazon    Software used To have a truly open-source project the software used is 100% free and open-source from the CAD project files to the software used to code and flash the code on the adalogger chip.\n   Type Software program Source link     CAD FreeCAD FreeCAD   Electronics KiCad EDA KiCad   Code environment and upload ArduinoIDE Arduino    Licences Since the E.C. project covers hardware and software licences that cover both are necessary. You can find the choosen licences in the \u0026ldquo;Licences folder\u0026rdquo; in PDF and .txt format.\n   Type License name Source link     Software GNU General Public License v3.0 or later SPDX   Hardware CERN-OHL-S-2.0 or any later version OHWR    The copyrights to both hardware and software are explicited in the copyright.pdf and copyright.md files and the original copies are stored in the License folder. If you want to apply any kind of change you always need to log it in the changes.md file and include all the original source and copyright files as per licences.\n","date":1596585600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596585600,"objectID":"d3d429f5ff1cef034b23adc46485194a","permalink":"https://gabri.xyz/projects/ec/","publishdate":"2020-08-05T00:00:00Z","relpermalink":"/projects/ec/","section":"projects","summary":"The electronic compass has the aim to create a low-cost, open-source electronic geological compass.","tags":["Geotechnics","Structural geology","Ec"],"title":"Electronic Compass","type":"projects"},{"authors":null,"categories":null,"content":"The premise The computing power of modern technologies and their rapid development gave the possibility to reconstruct 3D digital objects precisely and rapidly from the real world, increasing the possibility of their conservation and sharing. There are three different types of reconstruction techniques: photogrammetry, 3D scan and CT scan or tomography. These three methods are based on the fundamental concept of obtaining, interpreting, and measuring surface and objects properties without needing a direct contact with the object. This project gives a more in-depth look of photogrammetry, in particular the modern technique defined as Structure from Motion, applied to centimetric macroinvertebrate fossils. Photogrammetry is the most accessible and cost-effective method of the three. The project was entirely developed during the COVID-19 sanitary emergency using already available or easily obtainable equipment. As a second aim and long-term objective, the thesis works as a guide for further experimentation and automation of the process of data capture and processing and to create a digital palaeontological archive that can be used for online accurate analysis of specimens.\nProcedures In photogrammetry the digital reconstruction of an object is given by specialized software that can approximate the position of the photos relative to the object and its structure by capturing photos of different perspectives of the object. Since image capturing can be done with a passive sensor, photogrammetry is the most popular and diffused method of reconstruction. Furthermore, it can produce a textured model, process not always possible in 3D and CT scans. The software used in this project is Agisoft Metashape Professional because it has many tools, and it is efficiently optimized. Two main steps compose the reconstruction process:\n Image capture Computer processing.  The first step consists in a preliminary phase in which lights, camera and the specimen are positioned and the distance between the camera and the specimen is measured. Then, only when the user is certain that the specimen is in a stable fixed position the capturing process starts. The simplest capturing procedure consists in fixing the position of the camera and rotate the specimen on one axis. The angle of rotation needs to be small enough to have an 80% overlap between images. Lighting of the specimen needs to be diffused and multidirectional to avoid sharp shadows. The background needs to be featureless to avoid reconstruction errors.\nThe second step consists in importing the images into the software, process them and construct the final model. The processing in the software is divided in five main phases:\n Image masking Image alignment Formation of a dense cloud Meshing Texturing.  When the model is complete, it can be scaled to the real-world equivalent. In this way the measures taken on the model correspond to the real-world equivalent. For the processes that cannot be done inside the Agisoft Metashape software we proposed python codes precisely written for automatically completing some tasks (e.g. conversion of raw image files in jpg).\nFor the process of image capture, a Nikon D3100 reflex camera was used, in order to better control the focus, ISO and focal ratio parameters and used macro rings, in particular the 12+20mm combination, to capture the most minute details of the specimen. In order to avoid sharp shadows and give a homogeneous lighting to the specimens, we used two table lamps with diffused light. The background was black to increment the contrast with the specimen and help to differentiate the background from the object. To maintain the specimens in a fixed position crocodile-clips were used for a constant and strong grip. Each model was composed by 200 photos and took from 2 to 3 hours to complete. The model reconstruction process was applied to six specimens. Five of them were extracted from recent and Pleistocenic sediments in Solanto (Palermo, Italy), the former belonging to the Sintema di Marsala, precisely to the lithofacies of Calcareniti di Palermo. The sixth one was collected from recent sediments in California (USA). The classification was done by observing the macroscopic characteristics of the specimens and was aided by different texts.\nResults Spondylus gaederopus Linnaeus 1758   Venus verrucosa Linnaeus 1758   Pseudochama gryphina (Lamarck, 1819)   Haliotis tuberculata Linnaeus 1758   Dendraster excentricus (Eschscholtz, 1831)   Conclusions In general, photogrammetric programs have their limitations and cannot reconstruct smooth, reflective, and transparent surfaces. There were in fact some difficulties in reconstructing some characteristics of the studied specimens. The pallial line for example is not present in the models because it is hardly detectable also in the photos. The internal parts for some specimens also were not completely reconstructed because they were smooth and reflective. On the other hand, problems linked to the geometry of a particular specimen were easily resolved by modifying the alignment options. In the end, the results obtained from the application of photogrammetry on these six fossils demonstrate that this is a valid and accessible technique that can give accurate models. I hope in the future that this method of obtaining precise models very quickly can overcome the difficulties encountered and that it can be adopted as a standard to create an always-accessible repository where models can be shared and possibly 3D printed.\n","date":1587600000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587600000,"objectID":"7a929107d19d1b8a695d60db9db4c42b","permalink":"https://gabri.xyz/projects/fossils/","publishdate":"2020-04-23T00:00:00Z","relpermalink":"/projects/fossils/","section":"projects","summary":"Methods applied to obtain 3D accurate models of fossils using photogrammetry.","tags":["Paleontology","Photogrammetry"],"title":"3D paleontological objects","type":"projects"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://gabri.xyz/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]