<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | Gabriele Benedetti</title>
    <link>https://gabri.xyz/projects/</link>
      <atom:link href="https://gabri.xyz/projects/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021 Gabriele Benedetti</copyright><lastBuildDate>Tue, 22 Feb 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://gabri.xyz/media/sharing.png</url>
      <title>Projects</title>
      <link>https://gabri.xyz/projects/</link>
    </image>
    
    <item>
      <title>Tslist converter</title>
      <link>https://gabri.xyz/projects/tslist/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/tslist/</guid>
      <description>&lt;p&gt;TS lists are a type of output files that are produced by WRF during a simulation to register the calculated values in specific coordinates.
The raw output format of these files is not universal and it makes importing this kind of data a big hassle in other programs (such as excel). To contrast this problem I created this page that can be used to convert any TSLISTS in a properly formatted csv file and if necessary do some simple conversion and calculations (such as converting the time column from hours to days).&lt;/p&gt;
&lt;p&gt;This converter uses javascript to import and manipulate the data. Everything is done locally so it works even offline if the page is saved.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: For now batch conversion is not supported. You need to convert one file at a time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;todo&#34;&gt;Todo&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Batch conversions&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Mean calculations over time&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; User defined separator&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;converter&#34;&gt;Converter&lt;/h1&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&#34;UTF-8&#34;&gt;
  &lt;title&gt;File(s) size&lt;/title&gt;
  &lt;style&gt;
    html {
        font-family: sans-serif;
    }
    div#drop_box {
          height: 400px;
          width: 400px;
          border: 3px solid;
          display: flex;
          justify-content: center;
          flex-direction: column;
          align-items: center;
          border-radius: 4px;
      }
      input[type=&#39;file&#39;] {
  color: transparent;
}
      button, input[type=&#39;file&#39;]::file-selector-button {
        background-color: #4CAF50; /* Green */
        border: none;
        color: white;
        padding: 10px 15px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 20px;
        border-radius: 3px;
      }
      pre {
        display: -webkit-box;
        -webkit-line-clamp: 10;
        -webkit-box-orient: vertical;
      }
      .dropBox{
        font-size: 1.15em;
      }
      .formCtrl{
          font-size: 1.15em;
          font-weight: normal;
          line-height: 1.1;
          display: grid;
          grid-template-columns: 1em auto;
          gap: 0.5em;
      }
      input[type=&#39;radio&#39;]{
        width: 1em;
        height: 1em;
      }
    &lt;/style&gt;
&lt;/head&gt;
  &lt;h2&gt;Input options&lt;/h2&gt;
    &lt;input type=&#34;file&#34; id=&#34;file-selector&#34;  multiple&gt;
   &lt;br&gt;
   &lt;br&gt;
    or
    &lt;h4&gt; Drop to upload &lt;/h4&gt;
      &lt;div id=&#34;drop_box&#34;&gt;
        &lt;label class=&#34;dropBox&#34;&gt;Drop here&lt;/label&gt;
      &lt;/div&gt;
      &lt;h5&gt;Chosen file/s&lt;/h5&gt;
      &lt;pre id=&#39;fileBox&#39;&gt; &lt;/pre&gt;
      &lt;h2&gt;Conversion options&lt;/h2&gt;
      &lt;h3&gt;Time options&lt;/h3&gt;
      &lt;label for=&#34;convertTimeDay&#34; class=&#34;formCtrl&#34;&gt;
        &lt;input type=&#34;radio&#34; id=&#34;convertTimeDay&#34; value=&#34;td&#34; name=&#39;timeopt&#39;&gt;
        Convert hours in days
      &lt;/label&gt;
      &lt;label for=&#34;convertTimeMin&#34; class=&#34;formCtrl&#34;&gt;
        &lt;input type=&#34;radio&#34; id=&#34;convertTimeMin&#34; value=&#34;tm&#34; name=&#39;timeopt&#39;&gt;
        Convert hours in minutes
      &lt;/label&gt;
      &lt;label for=&#34;convertTimeSec&#34; class= &#34;formCtrl&#34;&gt;
        &lt;input type=&#34;radio&#34; id=&#34;convertTimeSec&#34; value=&#34;ts&#34; name=&#39;timeopt&#39;&gt;
         Convert hours in seconds
       &lt;/label&gt;
       &lt;label for=&#34;convertNone&#34; class= &#34;formCtrl&#34;&gt;
         &lt;input type=&#34;radio&#34; id=&#34;convertNone&#34; value=&#34;ts&#34; name=&#39;timeopt&#39; checked=&#34;checked&#34;&gt;
          Leave as is
        &lt;/label&gt;
       &lt;br&gt;
      &lt;button type=&#34;button&#34; id=&#34;convert_button&#34;&gt;&lt;i class=&#34;fas fa-exchange-alt&#34;&gt;&lt;/i&gt; Convert!&lt;/button&gt;
      &lt;hr&gt;
      &lt;h4&gt;Output&lt;/h4&gt;
      &lt;pre id=&#39;output&#39;&gt; &lt;/pre&gt;
      &lt;button type=&#34;button&#34; id=&#34;save_button&#34; onclick=&#34;saveCSV()&#34;&gt;&lt;i class=&#34;fa fa-save&#34;&gt;&lt;/i&gt; Save&lt;/button&gt;
      &lt;script&gt;
        function displayOutput(text){
          const outBox = document.getElementById(&#39;output&#39;);
          outBox.textContent = &#39;&#39;;
          outBox.textContent = text;
        }
        function saveCSV(){
          // console.log(newCSV)
          const  blob = new Blob([newCSV], {type: &#39;text/plain&#39;});
          const inFileName = fileList[0].name
          const fileName = inFileName + &#39;_toCSV.csv&#39;;
          let newLink = document.createElement(&#39;a&#39;);
          newLink.download = fileName;
          newLink.href = window.webkitURL.createObjectURL(blob);
          // newLink.style.display = &#39;none&#39;;
          // document.body.appendChild(newLink);
          newLink.click();
        }
        const tdCheckBox = document.getElementById(&#39;convertTimeDay&#39;);
        const tmCheckBox = document.getElementById(&#39;convertTimeMin&#39;);
        const tsCheckBox = document.getElementById(&#39;convertTimeSec&#39;);
        const fileSelector = document.getElementById(&#39;file-selector&#39;);
        const fileNameBox = document.getElementById(&#39;fileBox&#39;);
        fileSelector.addEventListener(&#39;change&#39;, (event) =&gt; {
          window.fileList = event.target.files;
          fileNameBox.textContent = event.target.files[0].name
        });
        const convertButton = document.getElementById(&#39;convert_button&#39;)
        convertButton.addEventListener(&#39;click&#39;,(event)=&gt;{
          var reader = new FileReader();
          var header = &#39;id;ts_hour;id_tsloc;ix;iy;t;q;u;v;psfc;glw;gsw;hfx;lh;tsk;tslb(1);rainc;rainnc;clw\n&#39;;
          reader.onload = function(){
              var infileName = window.fileList[0].name;
              var text = reader.result;
              var csv = header+text.split(&#39;\n&#39;).slice(1).join(&#39;\n&#39;).replace(/ \s+/g,&#39;;&#39;);
              // CSV and data manipulation
              var lines = csv.split(&#39;\n&#39;);
              var result = [];
              var headers = lines[0].split(&#39;;&#39;);
              for(var i=1; i&lt;lines.length;i++){
                var obj = {};
                var currentline = lines[i].split(&#39;;&#39;);
                // console.log(currentline)
                for(var j=0;j&lt;headers.length;j++){
                  obj[headers[j]] = currentline[j];
                }
                result.push(obj);
              }
              var jString = JSON.stringify(result);
              var jDF = JSON.parse(jString);
              // console.log(Object.values(jDF[0]));
              // DO stuff here
              for (i=0;i&lt;jDF.length;i++){
                if (tdCheckBox.checked == true){
                  jDF[i][&#39;ts_days&#39;] = jDF[i][&#39;ts_hour&#39;]/24;
                }
                else if (tmCheckBox.checked == true){
                  jDF[i][&#39;ts_minutes&#39;] = jDF[i][&#39;ts_hour&#39;]*60;
                }
                else if (tsCheckBox.checked == true){
                  jDF[i][&#39;ts_seconds&#39;] = jDF[i][&#39;ts_hour&#39;]*3600;
                }
              }
              // for(var k=0;j&lt; jDF.length;k++){
              //   console.log(jDF[k]);
              // }
              // console.log(jDF.length);
              // Save stuff
              // var keys = Object.keys(jDF[0]);
              window.newCSV = Object.keys(jDF[0]).join(&#39;;&#39;).trim()+&#39;\n&#39;;
              for (i=0;i&lt;jDF.length;i++){
                var line = Object.values(jDF[i]).join(&#39;;&#39;).trim()+&#39;\n&#39;;
                newCSV = newCSV+line
              }
              displayOutput(newCSV)
            }
            var files = window.fileList;
            reader.readAsText(files[0]);
          // console.log(reader.readAsDataURL(window.fileList[0]));
        });
        const dropZone = document.getElementById(&#39;drop_box&#39;);
        dropZone.addEventListener(&#39;dragover&#39;,(event)=&gt;{
          event.stopPropagation();
          event.preventDefault();
          // Style the drag-and-drop as a &#34;copy file&#34; operation.
          event.target.style.border = &#34;4px solid teal&#34;;
          event.target.style.color = &#34;teal&#34;;
          event.target.style.fontWeight = &#34;bold&#34;;
          event.dataTransfer.dropEffect = &#39;copy&#39;;
        });
        dropZone.addEventListener(&#39;dragleave&#39;,(event)=&gt;{
          event.stopPropagation();
          event.preventDefault();
          // Style the drag-and-drop as a &#34;copy file&#34; operation.
          event.target.style.border = &#34;3px solid&#34;;
          event.target.style.color = &#34;&#34;;
          event.target.style.fontWeight = &#34;normal&#34;;
        });
        dropZone.addEventListener(&#39;drop&#39;, (event) =&gt; {
          event.stopPropagation();
          event.preventDefault();
          event.target.style.border = &#34;3px solid&#34;;
          event.target.style.fontWeight = &#34;normal&#34;;
          event.target.style.color = &#34;&#34;;
          window.fileList = event.dataTransfer.files;
          fileNameBox.textContent = fileList[0].name
        });
      &lt;/script&gt;
&lt;/html&gt;
</description>
    </item>
    
    <item>
      <title>Pydip</title>
      <link>https://gabri.xyz/projects/pydip/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/pydip/</guid>
      <description>&lt;p&gt;Pydip is a python program with the main objective to give a stereoplot reading practice platform by generating random planes, folds, faults and focal mechanisms.&lt;/p&gt;
&lt;p&gt;As a secondary future objective, for now not implemented, the software will be able to plot and elaborate structural measurements obtained on the field (similar to &lt;a href=&#34;https://www.rickallmendinger.net/stereonet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stereonet&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The plots are generated with &lt;a href=&#34;https://github.com/joferkington/mplstereonet/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mplstereonet library&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;capabilities&#34;&gt;Capabilities:&lt;/h2&gt;
&lt;h3 id=&#34;generate-multiple-random-sets-of-planes&#34;&gt;Generate multiple random sets of planes&lt;/h3&gt;














&lt;figure  id=&#34;figure-ex_1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pydip/1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;The program chooses a random dip direction and angle for every set and depending on that plane the planes will be generated with a normal distribuition with a random std value.&lt;/p&gt;
&lt;p&gt;The parameters that can be tweaked are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number of sets&lt;/li&gt;
&lt;li&gt;Number of planes&lt;/li&gt;
&lt;li&gt;Plot planes and/or poles&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;generate-multiple-random-sets-of-folds&#34;&gt;Generate multiple random sets of folds&lt;/h3&gt;














&lt;figure  id=&#34;figure-rand_p&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pydip/2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;The program can generate n sets of random planes that follow random cilindrical fold parameters (axial plane and hinge line inclination etcetc).&lt;/p&gt;
&lt;p&gt;The parameters that can be tweaked are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number of sets of folds&lt;/li&gt;
&lt;li&gt;Number of planes for every fold limb&lt;/li&gt;
&lt;li&gt;Plot limb planes and/or poles&lt;/li&gt;
&lt;li&gt;Plot plane axis and/or hinge line&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;generate-random-focal-mechanisms&#34;&gt;Generate random focal mechanisms&lt;/h3&gt;














&lt;figure  id=&#34;figure-rand_p&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pydip/3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;data-table-view-and-selection&#34;&gt;Data table view and selection&lt;/h3&gt;














&lt;figure  id=&#34;figure-rand_p&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pydip/4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;import-and-plot-imported-data&#34;&gt;Import and plot imported data&lt;/h3&gt;
&lt;h2 id=&#34;planned-features&#34;&gt;Planned features:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Faults&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Better selection options&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Better import functions&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Statistics module&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 3D viewer for plotted structures&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rocpy</title>
      <link>https://gabri.xyz/projects/rocpy/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/rocpy/</guid>
      <description>&lt;h1 id=&#34;the-premise&#34;&gt;The premise&lt;/h1&gt;
&lt;p&gt;RocLab is a very useful piece of free software written in 2011 for determining rock mass strength parameters, based on the generalized Hoek-Brown failure criterion (Hoek et al. 2002). The main problem is that it is discontinued and the only version is available for windows. With this project I want to archive the same objective as RocLab&amp;rsquo;s using python to increase the overall accessibility of the program and improve the plot&amp;rsquo;s interfaces (thanks to matplotlib).&lt;/p&gt;
&lt;h1 id=&#34;capabilities&#34;&gt;Capabilities&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Calculate Hoek-Brown criterion parameters&lt;/li&gt;
&lt;li&gt;Calculate Rock mass parameters ($\sigma_t$, $\sigma_c$, $\sigma_{cm}$, $E_{rm}$)&lt;/li&gt;
&lt;li&gt;Calculate $\sigma_{3}^{max}$ based on different applications (e.g tunnels)&lt;/li&gt;
&lt;li&gt;Calculate Mohr-Coulomb parameters (c and $\phi$)&lt;/li&gt;
&lt;li&gt;Plot H-B and M-C envelope.&lt;/li&gt;
&lt;li&gt;Plot failure mohr circle and calculate the $\sigma_{1}^{max}$ value.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;













&lt;figure  id=&#34;figure-fig_1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/rocpy/HB.png&#34; alt=&#34;Main view with the HB crit plot&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Main view with the HB crit plot
    &lt;/figcaption&gt;&lt;/figure&gt;














&lt;figure  id=&#34;figure-fig_2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/rocpy/HB_MC.png&#34; alt=&#34;Main view with the HB and MC crit plot&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Main view with the HB and MC crit plot
    &lt;/figcaption&gt;&lt;/figure&gt;














&lt;figure  id=&#34;figure-fig_3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/rocpy/Mohr.png&#34; alt=&#34;Secondary veiw with the Mohr-Coulomb failure circle&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Secondary veiw with the Mohr-Coulomb failure circle
    &lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;future-additions&#34;&gt;Future additions:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Tabulated list values for D&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Tabulated list values for $m_i$&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Import data&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Export data&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pyseismic</title>
      <link>https://gabri.xyz/projects/pyseismic/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/pyseismic/</guid>
      <description>&lt;h1 id=&#34;the-premise&#34;&gt;The premise&lt;/h1&gt;
&lt;p&gt;Pyseismic is a simple python interface created to visualize and process seismic traces based on the &lt;a href=&#34;https://docs.obspy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Obspy package&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The aim of this project is to create a simple alternative to the more complex and costly &lt;a href=&#34;http://www.wgeosoft.ch/PDF/Visual_SUNT_Pro_Data.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Visual SUNT&lt;/a&gt; that can be used to do basic taks without the need to buy professional softwares. Since is entirely written in pyhon it can be run on every platform (Visual SUNT is only on Windows D:).&lt;/p&gt;
&lt;h1 id=&#34;capabilities&#34;&gt;Capabilities&lt;/h1&gt;
&lt;p&gt;For now there are very few functions available (the essentials). In particular seispy can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read and plot with matplotlib seismic traces from files supported on &lt;a href=&#34;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Obspy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pyseismic_images/1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apply FFT analysis on single or multiple traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pyseismic_images/2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basic filtering (band pass, low and high pass)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pyseismic_images/3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First break picking with options of live dromochrome plot.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/pyseismic_images/4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h1 id=&#34;future-capabilities&#34;&gt;Future capabilities&lt;/h1&gt;
&lt;p&gt;As it is this software is very bare bones but I have plans to expand it with more features such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Automatic first break&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Trace muting&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; More precise import options (as for now it relies on the autodetect features of Obspy)&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Simple stratigraphic model reconstruction (from dromochrome elaboration)&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Delaytime and GRM applications&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; SRCS&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Focal mechanism reconstruction&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Automatic processing for referenced slopes</title>
      <link>https://gabri.xyz/projects/auto-slope/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/auto-slope/</guid>
      <description>&lt;h1 id=&#34;the-premise&#34;&gt;The premise&lt;/h1&gt;
&lt;p&gt;This project was a request aimed to find a way to prepare different 3D models, in particular artificial slopes, and calculate the difference between two reconstructions after a given event directly in metashape &lt;strong&gt;without&lt;/strong&gt; using external programs.&lt;/p&gt;
&lt;p&gt;In particular the set of scripts needed to achive the following tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apply different masks for different sets of photos.&lt;/li&gt;
&lt;li&gt;Count the total number of markers detected in all of the uploaded photos. The number of markers needed to be in total always 135.&lt;/li&gt;
&lt;li&gt;Cut the resulting point clouds with constant dimensions and automatically apply a rotatation to make the plane horizontal.&lt;/li&gt;
&lt;li&gt;Calculate the difference between two meshes. To make sure that the difference operation was applied properly the two chunks need to be aligned and the models need to be rotated flat and cropped.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;













&lt;figure  id=&#34;figure-input-image-example&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/og_img.png&#34; alt=&#34;Input image example&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Input image example
    &lt;/figcaption&gt;&lt;/figure&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/slope_a2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;














&lt;figure  id=&#34;figure-reconstructed-slope-before-and-after-the-event&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/slope_b2.png&#34; alt=&#34;Reconstructed slope before and after the event&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Reconstructed slope before and after the event
    &lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;summary&#34;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;mask-application&#34;&gt;Mask application&lt;/h3&gt;
&lt;p&gt;The model is constructed using photos that capture a different angle of the artificial plane. The first step is to isolate the relevant slope information by masking the parts of the slope that are not needed for the reconstruction (e.g. the container). To do this different masks were created to mask specific parts present in different sets of photos. The pairing is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;photo 1 $\rightarrow$ &#39;&#39; Links_Initial.jpg &#39;&#39;&lt;/li&gt;
&lt;li&gt;photo 2 to 21 $\rightarrow$ &#39;&#39; Links_Regular.jpg &#39;&#39;&lt;/li&gt;
&lt;li&gt;photo 22 $\rightarrow$ &#39;&#39; Midden_Initial.jpg &#39;&#39;&lt;/li&gt;
&lt;li&gt;photo 23 to 42 $\rightarrow$ &#39;&#39; Midden_Regular.jpg &#39;&#39;&lt;/li&gt;
&lt;li&gt;photo 43 $\rightarrow$ &#39;&#39; Rechts_Initial.jpg &#39;&#39;&lt;/li&gt;
&lt;li&gt;photo 44 to 63 $\rightarrow$ &amp;lsquo;&amp;lsquo;Rechts_Regular.jpg &#39;&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This process was accomplished by writing the &lt;strong&gt;mask.py&lt;/strong&gt; script.&lt;/p&gt;
&lt;h3 id=&#34;marker-count&#34;&gt;Marker count&lt;/h3&gt;
&lt;p&gt;For each model there is a known fixed number of total markers that need to be detected (135). The objective of this script is to count the total amount of markers detected in the model and print if there are less than 135. This check is done to see if the automatic markers present for each markers are somehow cropped or masked out.&lt;/p&gt;
&lt;p&gt;The check process was automated using the &lt;strong&gt;check_markers.py&lt;/strong&gt; script&lt;/p&gt;
&lt;h3 id=&#34;cut-and-rotate-the-model-point-cloud&#34;&gt;Cut and rotate the model point cloud&lt;/h3&gt;
&lt;p&gt;To apply correctly the difference between the two models they both need to have the same size, position and rotation. To do this it was decided to rotate first the psarse cloud model and then resize the bounding box to a determined size. To do this the following process was defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Define the region size&lt;/li&gt;
&lt;li&gt;Find the minimum and maximum (for both x and y) points inside the bounding box and calculate the center (as the midpoint of points at opposite corners).&lt;/li&gt;
&lt;li&gt;Translate the points on the same height of the center point&lt;/li&gt;
&lt;li&gt;Set these points as tranform reference&lt;/li&gt;
&lt;li&gt;Update transform (and so rotate the points)&lt;/li&gt;
&lt;li&gt;Resize the bounding box&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To accurately rotate the model the plane needs to fit in the bounding box as tightly as possibile and so the z value need to be low. Too low z values can crop too much of the plane (since the plane has a certain inclination angle) and so the rotation won&amp;rsquo;t be as precise.&lt;/p&gt;
&lt;p&gt;This process is archived by using the &lt;strong&gt;region_size.py&lt;/strong&gt; script.&lt;/p&gt;
&lt;h3 id=&#34;mesh-difference&#34;&gt;Mesh difference&lt;/h3&gt;
&lt;p&gt;Instead of caluclating the difference of the two meshes a quicker is to convert the meshes in Digital Elevation Models and then apply a per pixel difference.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;final-workflow&#34;&gt;&lt;strong&gt;Final workflow&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;We can summarize the developed metashape workflow as follows:&lt;/p&gt;
&lt;center&gt;













&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/auto_slope_processing.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;&lt;/center&gt;
&lt;p&gt;This workflow is resonably fast and has the possibility to batch the processes to further automate the workflow.&lt;/p&gt;
&lt;center&gt;













&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/dem_a.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;&lt;/center&gt;
&lt;center&gt;













&lt;figure  id=&#34;figure-reconstructed-dem-of-the-slope-before-and-after-the-event&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/dem_b.png&#34; alt=&#34;Reconstructed DEM of the slope before and after the event&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      Reconstructed DEM of the slope before and after the event
    &lt;/figcaption&gt;&lt;/figure&gt;&lt;/center&gt;
&lt;center&gt;













&lt;figure  id=&#34;figure-dem-difference&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://gabri.xyz/media/auto_slope_img/diff2.png&#34; alt=&#34;DEM difference&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
      DEM difference
    &lt;/figcaption&gt;&lt;/figure&gt;&lt;/center&gt;
</description>
    </item>
    
    <item>
      <title>Electronic Compass</title>
      <link>https://gabri.xyz/projects/ec/</link>
      <pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/ec/</guid>
      <description>&lt;h1 id=&#34;the-premise&#34;&gt;The premise&lt;/h1&gt;
&lt;p&gt;This idea came to mind while doing university field trips in which we learned how to use a geological compass and how to take measurements (e.g. dip direction/dip) needed for geological interpretation and reconstruction of planes, folds etc..
A lot of time is lost, and error is introduced, in saving the appropriate txt file with the appropriate format and tabulation.
This project has the aim to create a low-cost, open-source electronic geological compass that reduces the time needed to take a measurement, write it down and afterwards rewrite in a txt to be used in other programs (Stereonet, wintensor&amp;hellip;) by creating a tool that works as a normal compass but can save the measurements locally in the appropriate files for different softwares.&lt;/p&gt;
&lt;p&gt;The planned compass features are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Measure dip and dip direction of a plane&lt;/li&gt;
&lt;li&gt;Measure strike slip, trend and plunge&lt;/li&gt;
&lt;li&gt;Quick profile switch (direction/dip, trend/plunge etc..)&lt;/li&gt;
&lt;li&gt;Automatic txt files save&lt;/li&gt;
&lt;li&gt;Calibration features&lt;/li&gt;
&lt;li&gt;Data elaboration software (pydip)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;components-list&#34;&gt;Components list&lt;/h2&gt;
&lt;p&gt;The Electronic Compass components are searched to be the most cost-effective and easy to solder available that I could find. I provide the links from where the components are purchased but some are europe based (mostly Germany) so check if worldwide shipping is convenient or not.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Component Name&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Quantity&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Price&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Adafruit adalogger M0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;26â¬&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://thepihut.com/products/adafruit-feather-m0-adalogger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ThePiHut&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GY-61 ADXL335 acceletometer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6.79â¬&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.az-delivery.de/en/products/gy-61-adxl335-beschleunigungssensor-3-axis-neigungswinkel-modul-1?variant=20332875546720&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AZ-Delivery&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;128x32 Oled display&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6.29â¬&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://thepihut.com/products/adafruit-feather-m0-adalogger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AZ-Delivery&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GY-271 QMC5883L magnetometer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.79â¬&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.az-delivery.de/en/products/gy-271-kompassmodul-kompass-magnet-sensor-fuer-arduino-und-raspberry-pi?variant=18912984432736&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AZ-Delivery&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SD card&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;may vary&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1200mAh 3.7V LiPo battery&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.36â¬&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.welectron.com/LiPo-Pouch-Battery-503562-37V-1200mAh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Welectron&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Potentiometer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Buttons&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x?&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&lt;a href=&#34;https://www.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;software-used&#34;&gt;Software used&lt;/h2&gt;
&lt;p&gt;To have a truly open-source project the software used is 100% free and open-source from the CAD project files to the software used to code and flash the code on the adalogger chip.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Type&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Software program&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Source link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CAD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FreeCAD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://www.freecadweb.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FreeCAD&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Electronics&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;KiCad EDA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://kicad.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KiCad&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Code environment and upload&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ArduinoIDE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://www.arduino.cc/en/software&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Arduino&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;licences&#34;&gt;Licences&lt;/h2&gt;
&lt;p&gt;Since the E.C. project covers hardware and software licences that cover both are necessary. You can find the choosen licences in the &amp;ldquo;Licences folder&amp;rdquo; in PDF and .txt format.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Type&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;License name&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Source link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Software&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GNU General Public License v3.0 or later&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://spdx.org/licenses/GPL-3.0-or-later.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPDX&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Hardware&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CERN-OHL-S-2.0 or any later version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://ohwr.org/cern_ohl_s_v2.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OHWR&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The copyrights to both hardware and software are explicited in the copyright.pdf and copyright.md files and the original copies are stored in the License folder. If you want to apply any kind of change you &lt;strong&gt;always need to log it in the changes.md file&lt;/strong&gt; and include all the original source and copyright files as per licences.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3D paleontological objects</title>
      <link>https://gabri.xyz/projects/fossils/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://gabri.xyz/projects/fossils/</guid>
      <description>&lt;h1 id=&#34;the-premise&#34;&gt;The premise&lt;/h1&gt;
&lt;p&gt;The computing power of modern technologies and their rapid development gave the possibility to reconstruct 3D digital objects precisely and rapidly from the real world, increasing the possibility of their conservation and sharing. There are three different types of reconstruction techniques: photogrammetry, 3D scan and CT scan or tomography. These three methods are based on the fundamental concept of obtaining, interpreting, and measuring surface and objects properties without needing a direct contact with the object.
This project gives a more in-depth look of photogrammetry, in particular the modern technique defined as Structure from Motion, applied to centimetric macroinvertebrate fossils. Photogrammetry is the most accessible and cost-effective method of the three. The project was entirely developed during the COVID-19 sanitary emergency using already available or easily obtainable equipment. As a second aim and long-term objective, the thesis works as a guide for further experimentation and automation of the process of data capture and processing and to create a digital palaeontological archive that can be used for online accurate analysis of specimens.&lt;/p&gt;
&lt;h1 id=&#34;procedures&#34;&gt;Procedures&lt;/h1&gt;
&lt;p&gt;In photogrammetry the digital reconstruction of an object is given by specialized software that can approximate the position of the photos relative to the object and its structure by capturing photos of different perspectives of the object. Since image capturing can be done with a passive sensor, photogrammetry is the most popular and diffused method of reconstruction. Furthermore, it can produce a textured model, process not always possible in 3D and CT scans. The software used in this project is Agisoft Metashape Professional because it has many tools, and it is efficiently optimized.
Two main steps compose the reconstruction process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Image capture&lt;/li&gt;
&lt;li&gt;Computer processing.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first step consists in a preliminary phase in which lights, camera and the specimen are positioned and the distance between the camera and the specimen is measured. Then, only when the user is certain that the specimen is in a stable fixed position the capturing process starts. The simplest capturing procedure consists in fixing the position of the camera and rotate the specimen on one axis. The angle of rotation needs to be small enough to have an 80% overlap between images. Lighting of the specimen needs to be diffused and multidirectional to avoid sharp shadows. The background needs to be featureless to avoid reconstruction errors.&lt;/p&gt;
&lt;p&gt;The second step consists in importing the images into the software, process them and construct the final model. The processing in the software is divided in five main phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Image masking&lt;/li&gt;
&lt;li&gt;Image alignment&lt;/li&gt;
&lt;li&gt;Formation of a dense cloud&lt;/li&gt;
&lt;li&gt;Meshing&lt;/li&gt;
&lt;li&gt;Texturing.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When the model is complete, it can be scaled to the real-world equivalent. In this way the measures taken on the model correspond to the real-world equivalent. For the processes that cannot be done inside the Agisoft Metashape software we proposed python codes precisely written for automatically completing some tasks (e.g. conversion of raw image files in jpg).&lt;/p&gt;
&lt;p&gt;For the process of image capture, a Nikon D3100 reflex camera was used, in order to better control the focus, ISO and focal ratio parameters and used macro rings, in particular the 12+20mm combination, to capture the most minute details of the specimen.
In order to avoid sharp shadows and give a homogeneous lighting to the specimens, we used two table lamps with diffused light. The background was black to increment the contrast with the specimen and help to differentiate the background from the object. To maintain the specimens in a fixed position crocodile-clips were used for a constant and strong grip. Each model was composed by 200 photos and took from 2 to 3 hours to complete.
The model reconstruction process was applied to six specimens. Five of them were extracted from recent and Pleistocenic sediments in Solanto (Palermo, Italy), the former belonging to the Sintema di Marsala, precisely to the lithofacies of Calcareniti di Palermo. The sixth one was collected from recent sediments in California (USA). The classification was done by observing the macroscopic characteristics of the specimens and was aided by different texts.&lt;/p&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;h2 id=&#34;spondylus-gaederopus-linnaeus-1758&#34;&gt;Spondylus gaederopus Linnaeus 1758&lt;/h2&gt;
&lt;div class=&#34;sketchfab-embed-wrapper&#34;&gt; &lt;iframe title=&#34;Spondylus gaedropus Linnaeus, 1758&#34; frameborder=&#34;0&#34; allowfullscreen mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; allow=&#34;autoplay; fullscreen; xr-spatial-tracking&#34; xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://sketchfab.com/models/584903c4d4784c8babc3f3ecd5ef3e87/embed?ui_theme=dark&#34;&gt; &lt;/iframe&gt; &lt;/div&gt;
&lt;h2 id=&#34;venus-verrucosa-linnaeus-1758&#34;&gt;Venus verrucosa Linnaeus 1758&lt;/h2&gt;
&lt;div class=&#34;sketchfab-embed-wrapper&#34;&gt; &lt;iframe title=&#34;Venus verrucosa Linnaeus, 1758&#34; frameborder=&#34;0&#34; allowfullscreen mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; allow=&#34;autoplay; fullscreen; xr-spatial-tracking&#34; xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://sketchfab.com/models/e89ba09d34524d58ae30e41cfa89934c/embed?ui_theme=dark&#34;&gt; &lt;/iframe&gt; &lt;/div&gt;
&lt;h2 id=&#34;pseudochama-gryphina-lamarck-1819&#34;&gt;Pseudochama gryphina (Lamarck, 1819)&lt;/h2&gt;
&lt;div class=&#34;sketchfab-embed-wrapper&#34;&gt; &lt;iframe title=&#34;Pseudochama gryphina (Lamarck, 1819)&#34; frameborder=&#34;0&#34; allowfullscreen mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; allow=&#34;autoplay; fullscreen; xr-spatial-tracking&#34; xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://sketchfab.com/models/504d073d93f24aa1ab1ce0ae6f0b0f9c/embed?ui_theme=dark&#34;&gt; &lt;/iframe&gt; &lt;/div&gt;
&lt;h2 id=&#34;haliotis-tuberculata-linnaeus-1758&#34;&gt;Haliotis tuberculata Linnaeus 1758&lt;/h2&gt;
&lt;div class=&#34;sketchfab-embed-wrapper&#34;&gt; &lt;iframe title=&#34;Haliotis tubercolata Linnaeus, 1758&#34; frameborder=&#34;0&#34; allowfullscreen mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; allow=&#34;autoplay; fullscreen; xr-spatial-tracking&#34; xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://sketchfab.com/models/aeda69fe209346c9abb06bdd3678996c/embed?ui_theme=dark&#34;&gt; &lt;/iframe&gt; &lt;/div&gt;
&lt;h2 id=&#34;dendraster-excentricus-eschscholtz-1831&#34;&gt;Dendraster excentricus (Eschscholtz, 1831)&lt;/h2&gt;
&lt;div class=&#34;sketchfab-embed-wrapper&#34;&gt; &lt;iframe title=&#34;Dendraster excentricus (Eschscholtz, 1831)&#34; frameborder=&#34;0&#34; allowfullscreen mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; allow=&#34;autoplay; fullscreen; xr-spatial-tracking&#34; xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://sketchfab.com/models/8fc81dcc71a14aadb96a9b47e99a6850/embed?ui_theme=dark&#34;&gt; &lt;/iframe&gt; &lt;/div&gt;
&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;In general, photogrammetric programs have their limitations and cannot reconstruct smooth, reflective, and transparent surfaces. There were in fact some difficulties in reconstructing some characteristics of the studied specimens. The pallial line for example is not present in the models because it is hardly detectable also in the photos. The internal parts for some specimens also were not completely reconstructed because they were smooth and reflective. On the other hand, problems linked to the geometry of a particular specimen were easily resolved by modifying the alignment options.
In the end, the results obtained from the application of photogrammetry on these six fossils demonstrate that this is a valid and accessible technique that can give accurate models. I hope in the future that this method of obtaining precise models very quickly can overcome the difficulties encountered and that it can be adopted as a standard to create an always-accessible repository where models can be shared and possibly 3D printed.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
